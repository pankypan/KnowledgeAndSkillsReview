# 5 Linux 内核体系结构

从分层的角度来看，一个完整的操作系统可由 4 部分组成：硬件、操作系统内核、操作系统服务和用户应用程序，见图 5-1 所示。用户应用程序是指那些字处理程序、Internet 浏览器程序或用户自行编制的各种应用程序；操作系统服务程序是指那些向用户提供的服务和被看作是操作系统部分功能的程序。在 Linux 操作系统中，这些程序包括 X 窗口系统、shell 命令解释系统以及那些内核编程接口等系统程序；操作系统内核程，它主要用于对硬件资源进行抽象，并对所有系统资源进行调度管理。

![1727426543318](assets/1727426543318.png)

Linux 内核的主要用途就是为了与计算机硬件进行交互，实现对硬件部件的接口操作和编程控制，对硬件资源进行访问调度，并为计算机上的用户程序提供一个便于使用的执行环境和通用的硬件虚拟接口。





## 5.1 Linux 内核模式

操作系统内核的结构模式主要可分为**整体式的单内核模式**和**层次式的微内核模式**，以及这两者的混合模式。本书所注释的 Linux 0.12 内核采用的是单内核模式。

在单内核模式的系统中，操作系统所提供服务的流程为：应用主程序使用指定的参数值执行系统调用指令(int x80)，使 CPU 从用户态（User Mode）切换到核心态（Kernel Model），然后操作系统根据具体的参数值调用特定的系统调用服务程序，而这些服务程序则根据需要再调用底层的一些支持函数以完成特定的功能。在完成了应用程序所要求的服务后，操作系统又使 CPU 从核心态切换回用户态，从而返回到应用程序中继续执行后面的指令。

见图 5-2 所示。单内核模式的主要优点是内核代码结构紧凑、执行速度快，不足之处主要是层次结构性不强。

![1727426655345](assets/1727426655345.png)

对于微内核结构模式，其主要特点是系统功能的模块化和消息传递。系统核心提供一个最基本的硬件抽象管理层和关键系统服务功能。这些关键功能主要进程/线程间通信服务、虚拟内存管理和进程调度等。操作系统其余功能则以各种模块化的形式在用户空间中运行。因此，微内核结构的优点是系统服务偶合度低，便于系统的改进、扩展和移植。主要缺点则是在系统运行期间需要通过消息传递方式，在微核心和系统各服务进程模块之间进行大量消息传递和同步操作，而这些操作会造成通信资源耗费和时间上的延迟。





## 5.2 Linux 内核系统体系结构

Linux 内核主要由 5 个模块构成，它们分别是：进程调度模块、内存管理模块、文件系统模块、进程间通信模块和网络接口模块。

这几个模块之间的依赖关系见图 5-3 所示。其中的连线代表它们之间的依赖关系，虚线和虚框部分表示 Linux 0.12 中还未实现的部分

![1727426726560](assets/1727426726560.png)



若从单内核模式结构模型出发，我们还可以根据 Linux 0.12 内核源代码的结构将内核主要模块绘制成图 5-4 所示的框图结构。

![1727426754662](assets/1727426754662.png)









## 5.3 Linux 内核对内存的管理和使用

### 5.3.1物理内存

在 Linux 0.12 内核中，为了有效地使用机器中的物理内存，在**系统初始化阶段**内存被划分成几个功能区域，见图 5-5 所示。

![1727426809653](assets/1727426809653.png)

其中，Linux 内核程序占据在物理内存的开始部分，接下来是供硬盘或软盘等块设备使用的高速缓冲区部分（其中要扣除显示卡内存和 ROM BIOS 所占用的内存地址范围 640K--1MB）。当一个进程需要读取块设备中的数据时，系统会首先把数据读到高速缓冲区中；当有数据需要写到块设备上去时，系统也是先将数据放到高速缓冲区中，然后由块设备驱动程序写到相应的设备上。内存的最后部分是供所有程序可以随时申请和使用的主内存区。



在 Intel 80386 及以后的 CPU 中提供了两种内存管理（地址变换）系统：**内存分段系统（Segmentation System）**和**分页系统（Paging System）**。为了能有效地使用物理内存，**Linux 系统同时采用了内存分段和分页管理机制**。





### 5.3.2内存地址空间概念

Linux 0.12 内核中，在进行地址映射操作时，我们需要首先分清 3 种地址以及它们之间的变换概念：

- a. **程序（进程）的虚拟和逻辑地址**；
- b. **CPU 的线性地址**；
- c. 实际**物理内存地址**。



**虚拟地址（Virtual Address）**是指由程序产生的由**段选择符**和**段内偏移地址**两个部分组成的地址。

- 因为这两部分组成的地址并没有直接用来访问物理内存，而是需要通过分段地址变换机制处理或映射后才

  对应到物理内存地址上，因此这种地址被称为虚拟地址。

- **虚拟地址空间**由 GDT 映射的全局地址空间和由 LDT 映射的局部地址空间组成。

- 选择符的索引部分由 13 个比特位表示，加上区分 GDT 和 LDT 的 1个比特位，因此 Intel 80X86 CPU 共可以索引 16384 个选择符。若每个段的长度都取最大值 4G，则最大虚拟地址空间范围是 16384 * 4G = 64T。



**逻辑地址（Logical Address）**是指由程序产生的**与段相关的偏移地址部分**。

- 在 Intel 保护模式下即是指程序执行代码段限长内的偏移地址（假定代码段、数据段完全一样）。
- 应用程序员仅需与逻辑地址打交道，而分段和分页机制对他来说是完全透明的，仅由系统编程人员涉及。
- 不过有些资料并不区分逻辑地址和虚拟地址的概念，而是将它们统称为逻辑地址。



**线性地址（Linear Address）**是虚拟地址到物理地址变换之间的中间层，是处理器可寻址的内存空间（称为线性地址空间）中的地址。

- 程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。
- 如果启用了分页机制，那么线性地址可以再经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。
- Intel 80386 的线性地址空间容量为 4G。



**物理地址（Physical Address）**是指出现在 CPU 外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。



虚拟存储（或虚拟内存）（Virtual Memory）是指计算机呈现出要比实际拥有的内存大得多的内存量。因此它允许程序员编制并运行比实际系统拥有的内存大得多的程序。这使得许多大型项目也能够在具有有限内存资源的系统上实现。

**有时我们也把逻辑地址称为虚拟地址**。因为逻辑地址与虚拟内存空间的概念类似，并且也是与实际物理内存容量无关。





### 5.3.3内存分段机制

图 5-6 虚拟地址（逻辑地址）到物理地址的变换过程

![1727427337282](assets/1727427337282.png)



那么虚拟存储管理是怎样实现的呢？首先，当一个程序需要使用一块不存在的内存时（也即在内存页表项中已标出相应内存页面不在内存中），CPU 就需要一种方法来得知这个情况。这是通过 80386 的页错误异常中断来实现的。当一个进程引用一个不存在页面中的内存地址时，就会触发 CPU 产生页出错异常中断，并把引起中断的线性地址放到 CR2 控制寄存器中。因此处理该中断的过程就可以知道发生页异常的确切地址，从而可以把进程要求的页面从二级存储空间（比如硬盘上）加载到物理内存中。如果此时物理内存已经被全部占用，那么可以借助二级存储空间的一部分作为交换缓冲区（Swapper）把内存中暂时不使用的页面交换到二级缓冲区中，然后把要求的页面调入内存中。这也就是内存管理的缺页加载机制，在 Linux 0.12 内核中是在程序 mm/memory.c 中实现。



假定大家知晓实模式下内存寻址原理，现在我们根据 CPU 在实模式和保护模式下寻址方式的不同，用比较的方法来简单说明 32 位保护模式运行机制下内存寻址的主要特点。如图 5-7 实模式与保护模式下寻址方式的比较

![1727427493821](assets/1727427493821.png)





由 GDT 映射的地址空间称为全局地址空间，由 LDT 映射的地址空间则称为局部地址空间，而这两者构成了虚拟地址的空间。具体的使用方式见图 5-8 所示。

![1727427733839](assets/1727427733839.png)

图中画出了具有两个任务时的情况。可以看出，每个任务的局部描述符表 LDT 本身也是由 GDT 中描述符定义的一个内存段，在该段中存放着对应任务的代码段和数据段描述符，因此 LDT 段很短，其段限长通常只要大于 24 字节即可。同样，每个任务的任务状态段 TSS 也是由 GDT 中描述符定义的一个内存段，其段限长也只要满足能够存放一个 TSS 数据结构就够了。







### 5.3.4内存分页管理

若采用了分页机制，则此时线性地址只是一个中间结果，还需要使用分页机制进行变换，再最终映射到实际物理内存地址上。

内存分页管理机制的基本原理是将 CPU 整个线性内存区域划分成 4096 字节为 1 页的内存页面。程序申请使用内存时，系统就以内存页为单位进行分配。内存分页机制的实现方式与分段机制很相似，但并不如分段机制那么完善。因为分页机制是在分段机制之上实现的，所以其结果是对系统内存具有非常灵活的控制权，并且在分段机制的内存保护上更增加了分页保护机制。为了在 80X86 保护模式下使用分页机制，需要把控制寄存器 CR0 的最高比特位（位 31）置位。



线性地址到物理地址的变换过程见图 5-9 所示。图中**控制寄存器 CR3** 保存着是**当前页目录表在物理内存中的基地址**（因此 CR3 也被称为页目录基地址寄存器 PDBR）。

![1727427825707](assets/1727427825707.png)





由于 Linux 0.12 中把每个进程最大可用虚拟内存空间定义为 64MB，因此每个进程的逻辑地址通过加上(任务号)*64MB，即可转换为线性空间中的地址。





对于 Linux 0.12 系统，内核设置全局描述符表 GDT 中的段描述符项数最大为 256，其中 2 项空闲、2 项系统使用，每个进程使用两项。因此，此时系统可以最多容纳(256-4)/2 =126 个任务，并且虚拟地址范围是 ((256-4)/2)* 64MB 约等于 8G。但 0.12 内核中人工定义最大任务数 NR_TASKS = 64 个，每个任务逻辑地址范围是 64M，并且各个任务在线性地址空间中的起始位置是 (任务号)*64MB。因此全部任务所使用的线性地址空间范围是 64MB*64 =4G，见图 5-10 所示。

![1727427955111](assets/1727427955111.png)

如果也按照线性空间中任务的排列顺序排列虚拟空间中的任务，那么我们可以有图 5-11 所示的系统同时可拥有所有任务在虚拟地址空间中的示意图，所占用虚拟空间范围也是 4GB。其中没有考虑内核代码和数据在虚拟空间中所占用的范围。另外，在图中对于进程 2 和进程 3 还分别给出了各自逻辑空间中代码段和数据段（包括数据和堆栈内容）的位置示意图。

![1727427985822](assets/1727427985822.png)

请还需注意，进程逻辑地址空间中代码段（Code Section）和数据段（Data Section）的概念与 CPU分段机制中的代码段和数据段不是同一个概念。CPU 分段机制中段的概念确定了在线性地址空间中一个段的用途以及被执行或访问的约束和限制，每个段可以设置在 4GB 线性地址空间中的任何地方，它们可以相互独立也可以完全重叠或部分重叠。而进程在其逻辑地址空间中的代码段和数据段则是指由编译器在编译程序和操作系统在加载程序时规定的在进程逻辑空间中顺序排列的代码区域、初始化和未初始化的数据区域以及堆栈区域。进程逻辑地址空间中代码段和数据段等结构形式见图所示。其中 nr 是任务号，start_code 是进程或任务在线性地址空间的起始位置。其他变量均表示进程在逻辑空间中的值。

![1727428008072](assets/1727428008072.png)







### 5.3.5CPU 多任务和保护方式

Intel 80X86 CPU 共分 4 个保护级，0 级具有最高优先级，而 3 级优先级最低。Linux 0.12 操作系统使用了 CPU 的 0 和 3 两个保护级。内核代码本身会由系统中的所有任务共享。而每个任务则都有自己的代码和数据区，这两个区域保存于局部地址空间，因此系统中的其他任务是看不见的（不能访问的）。而内核代码和数据是由所有任务共享的，因此它保存在全局地址空间中。图 5-13 给出了这种结构的示意图。

![1727428126280](assets/1727428126280.png)







### 5.3.6虚拟地址、线性地址和物理地址之间的关系

**内核代码和数据的地址**

- 对于 Linux 0.12 内核代码和数据来说，在 head.s 程序的初始化操作中已经把**内核代码段和数据段都设置成为长度为 16MB 的段。在线性地址空间中这两个段的范围重叠，都是从线性地址 0 开始到地0xFFFFFF 共 16MB 地址范围。**在该范围中含有内核所有的代码、内核段表（GDT、IDT、TSS）、页目录表和内核的二级页表、内核局部数据以及内核临时堆栈（将被用作第 1 个任务即任务 0 的用户堆栈）。其页目录表和二级页表已设置成把 0--16MB 的线性地址空间一一对应到物理地址上，占用了 4 个目录项，即 4 个二级页表。因此对于内核代码或数据的地址来说，我们可以直接把它们看作是物理内存中的地址。此时内核的虚拟地址空间、线性地址空间和物理地址空间三者之间的关系可用图 5-14 来表示。

  ![1727428256768](assets/1727428256768.png)

- 通过上述分析可以看出：①内核代码段和数据段区域在线性地址空间和物理地址空间中是一样的。这样设置可以大大简化内核的初始化操作。②GDT 和 IDT 在内核数据段中，因此它们的线性地址也同样等于它们的物理地址。在实模式下的 setup.s 程序初始化操作中，我们曾经设置过临时的 GDT和 IDT，这是进入保护模式之前必须设置的。由于这两个表当时处于物理内存大约 0x90200 处，而进入保护模式后内核系统模块处于物理内存 0 开始位置，并且 0x90200 处的空间将被挪作他用（用于高速缓冲），因此在进入保护模式后，在运行的第 1 个程序 head.s 中我们需要重新设置这两个表。即设置 GDTR和 IDTR 指向新的 GDT 和 IDT，描述符也需要重新加载。但由于开启分页机制时这两个表的位置没有变动，因此无须再重新建立或移动表位置。③除任务 0 以外，所有其他任务使用的物理内存页面与线性地址中的页面起码有部分不同，因此内核需要动态地在主内存区中为它们作映射操作，动态地建立页目录项和页表项。

- 虽然 Linux 0.12 默认可管理 16MB 物理内存，但是系统中并不是一定要有这些物理内存。机器中只要有 4MB（甚至 2MB）物理内存就完全可以运行 Linux 0.12 系统了。若机器只有 4MB 物理内存，那么此时内核 4MB--16MB 地址范围就会映射到不存在的物理内存地址上。





**任务 0 的地址对应关系**

- 任务 0 是系统中一个人工启动的第一个任务。它的代码段和数据段长度被设置为 640KB。该任务的代码和数据直接包含在内核代码和数据中，是从线性地址 0 开始的 640KB 内容，因此可以它直接使用内核代码已经设置好的页目录和页表进行分页地址变换。同样，它的代码和数据段在线性地址空间中也是重叠的。对应的任务状态段 TSS0 也是手工预设置好的，并且位于任务 0 数据结构信息中，参见`include/linux/sched.h` 第 156 行开始的数据。三个地址空间中的映射对应关系见图 5-15 所示。

  ![1727428421194](assets/1727428421194.png)

- 由于任务 0 直接被包含在内核代码中，因此不需要为其再另外分配内存页。它运行时所需要的内核态堆栈和用户态堆栈空间也都在内核代码区中





**任务 1 的地址对应关系**

- 与任务 0 类似，任务 1 也是一个特殊的任务。它的代码也在内核代码区域中。与任务 0 不同的是在线性地址空间中，系统在使用 fork()创建任务 1（init 进程）时为存放任务 1 的二级页表而在主内存区申请了一页内存来存放，并复制了父进程（任务 0）的页目录和二级页表项。因此任务 1 有自己的页目录和页表表项，它把任务 1 占用的线性空间范围 64MB--128MB（实际上是 64MB--64MB+640KB）也同样映射到了物理地址 0--640KB 处。此时任务 1 的长度也是 640KB，并且其代码段和数据段相重叠，只占用一个页目录项和一个二级页表。另外，系统还会为任务 1 在主内存区域中申请一页内存用来存放它的任务数据结构和用作任务 1 的内核堆栈空间。任务数据结构（也称进程控制块 PCB）信息中包括任务 1的 TSS 段结构信息。见图 5-16 所示。

  ![1727428492548](assets/1727428492548.png)

- 任务 1 的用户态堆栈空间将直接共享使用处于内核代码和数据区域（线性地址 0--640KB）中任务 0的用户态堆栈空间 user_stack[](参见 kernel/sched.c，第 82--87 行)，因此这个堆栈需要在任务 1 实际使用之前保持“干净”，以确保被复制用于任务 1 的堆栈不含有无用数据。





**其他任务的地址对应关系**

- 对于被创建的从任务 2 开始的其他任务，它们的父进程都是 init（任务 1）进程。
- 从任务 2 开始，如果任务号以 nr 来表示，那么任务 nr 在线性地址空间中的起始位置将被设定在nr*64MB 处。例如任务 2 的开始位置= nr*64MB = 2 * 64MB = 128MB。任务代码段和数据段的最大长度被设置为 64MB，因此任务 2 占有的线性地址空间范围是 128MB--192MB，共占用 64MB/4MB = 16 个页目录项。虚拟空间中任务代码段和数据段都被映射到线性地址空间相同的范围，因此它们也完全重叠。图 5-17 显示出了任务 2 的代码段和数据段在三种地址空间中的对应关系。
- 在任务 2 被创建出来之后，将在其中运行 execve()函数来执行 shell 程序。当内核通过复制任务 1 刚创建任务 2 时，除了占用线性地址空间范围不同外（128MB--128MB+640KB），此时任务 2 的代码和数据在三种地址空间中的关系与任务 1 的类似。当任务 2 的代码（init()）调用 execve()系统调用开始加载并执行 shell 程序时，该系统调用会释放掉从任务 1 复制的页目录和页表表项及相应内存页面，然后为新的执行程序 shell 重新设置相关页目录和页表表项。图 5-17 给出的是任务 2 中开始执行 shell 程序时的情况，即任务 2 原先复制任务 1 的代码和数据被 shell 程序的代码段和数据段替换后的情况。图中显示出已经映射了一页物理内存页面的情况。这里请注意，在执行 execve()函数时，系统虽然在线性地址空间为任务 2 分配了 64MB 的空间范围，但是内核并不会立刻为其分配和映射物理内存页面。只有当任务 2 开始执行时由于发生缺页而引起异常时才会由内存管理程序为其在主内存区中分配并映射一页物理内存到其线性地址空间中。这种分配和映射物理内存页面的方法称为需求加载（Load on demand）。

![1727428643774](assets/1727428643774.png)







### 5.3.7用户申请内存的动态分配

当用户应用程序使用 C 函数库中的内存分配函数 malloc()申请内存时，这些动态申请的内存容量或大小均由高层次的 C 库函数 malloc()来进行管理，内核本身并不会插手管理。因为内核已经为每个进程（除了任务 0 和 1，它们与内核代码一起常驻内存中）在 CPU 的 4G 线性地址空间中分配了 64MB 的空间，所以只要进程执行时寻址的范围在它的 64MB 范围内，内核也同样会通过内存缺页管理机制自动为寻址对应的页面分配物理内存页面并进行映射操作。但是内核会为进程使用的代码和数据空间维护一个当前位置值 brk，这个值保存在每个进程的数据结构中。它指出了进程代码和数据（包括动态分配的数据空间）在进程地址空间中的末端位置。当 malloc()函数为程序分配内存时，它会通过系统调用 brk()把程序要求新增的空间长度通知内核，内核代码从而可以根据 malloc()所提供的信息来更新 brk 的值，但并此时并不为新申请的空间映射物理内存页面。只有当程序寻址到某个不存在对应物理页面的地址时，内核才会进行相关物理内存页面的映射操作。

若进程代码寻址的某个数据所在的页面不存在，并且该页面所处位置属于进程堆范围，即不属于其执行文件映像文件对应的内存范围中，那么 CPU 就会产生一个缺页异常，并在异常处理程序中为指定的页面分配并映射一页物理内存页面。至于用户程序此次申请内存的字节长度数量和在对应物理页面中的具体位置，则均由 C 库中内存分配函数 malloc()负责管理。内核以页面为单位分配和映射物理内存，该函数则具体记录用户程序使用了一页内存的多少字节。剩余的容量将保留给程序再申请内存时使用。

当用户使用内存释放函数 free()动态释放已申请的内存块时，C 库中的内存管理函数就会把所释放的内存块标记为空闲，以备程序再次申请内存时使用。在这个过程中内核为该进程所分配的这个物理页面并不会被释放掉。只有当进程最终结束时内核才会全面收回已分配和映射到该进程地址空间范围的所有物理内存页面。







## 5.4 中断机制

### 5.4.1中断操作原理

当设备向处理器提出服务请求时，处理器会在执行完当前的一条指令后立刻应答设备的请求，并转而执行该设备的相关服务程序。当服务程序执行完成后，处理器会接着去做刚才被中断的程序。这种处理方式就叫做中断（Interrupt）方法，而设备向处理器发出的服务请求则称为中断请求（IRQ - Interrupt Request）。处理器响应请求而执行的设备相关程序则被称为中断服务程序或中断服务过程（ISR - Interrupt Service Routine）。

可编程中断控制器（PIC - Programmable Interrupt Controller）是微机系统中管理设备中断请求的管理者。它通过连接到设备的中断请求引脚接受设备发出的终端服务请求信号。当设备激活其中断请求 IRQ信号时，PIC 立刻会检测到。在同时收到几个设备的中断服务请求的情况下，PIC 会对它们进行优先级比较并选出最高优先级的中断请求进行处理。当 PIC 向处理器的 INT 引脚发出一个中断信号时，处理器会立刻停下当时所做的事情并询问 PIC 需要执行哪个中断服务请求。PIC 则通过向数据总线发送出与中断请求对应的中断号来告知处理器要执行哪个中断服务过程。处理器则根据读取的中断号通过查询中断向量表（或 32位保护模式下的中断描述符表）取得相关设备的中断向量（即中断服务程序的地址）并开始执行中断服务程序。当中断服务程序执行结束，处理器就继续执行被中断信号打断的程序。

以上描述的是输入输出设备的中断服务处理过程。但是中断方法并非一定与硬件相关，它也可以用于软件中。通过使用 int 指令并使用其操作数指明中断号，就可以让处理器去执行相应的中断处理过程。





### 5.4.2 80X86 微机的中断子系统

在使用 80X86 组成的微机系统中采用了 8259A 可编程中断控制器芯片。每个 8259A 芯片可以管理 8个中断源。在 PC/AT 系列兼容机中，使用了两片 8259A 芯片，共可管理 15 级中断向量。其级联示意图见图 5-18 所示。

![1727428918689](assets/1727428918689.png)





### 5.4.3中断向量表

上节已指出 CPU 是根据中断号获取中断向量值，即对应中断服务程序的入口地址值。因此为了让CPU 由中断号查找到对应得中断向量，就需要在内存中建立一张查询表，即中断向量表（在 32 位保护模式下该表称为中断描述符表，见下面说明）。80X86 微机支持 256 个中断，对应每个中断需要安排一个中断服务程序。在 80X86 实模式运行方式下，每个中断向量由 4 个字节组成。这 4 个字节指明了一个中断服务程序的段值和段内偏移值。因此整个向量表的长度为 1024 字节。



当 Intel CPU 运行在 32 位保护模式下时，需要使用中断描述符表 IDT（Interrupt Descriptor Table）来管理中断或异常。IDT 是 Intel 8086 -- 80186 CPU 中使用的中断向量表的直接替代物。其作用也类似于中断向量表，只是其中每个中断描述符项中除了含有中断服务程序地址以外，还包含有关特权级和描述符类别等信息。







### 5.4.4 Linux 内核的中断处理

对于 Linux 内核来说，中断信号通常分为两类：硬件中断和软件中断(异常)。每个中断是由 0-255之间的一个数字来标识，称为中断号。对于中断 INT0--INT31(0x00--0x1F)，每个中断的功能由 Intel 公司固定设定或保留用，见下表 5-1 所示。 

![1727429005018](assets/1727429005018.png)

![1727429016015](assets/1727429016015.png)

这些中断属于软件中断，Intel 公司称之为异常，因为这些中断是在 CPU 执行指令时探测到异常情况而引起的。通常还可分为故障(Fault)和陷阱(Traps)两类。中断 INT32--INT255 (0x20--0xFF)可以由用户自己设定。所有中断的分类以及执行后 CPU 的动作方式见表 5–2 所示。

![1727429040334](assets/1727429040334.png)

在 Linux 系统中，则将 INT32--INT47（0x20--0x2F）对应于 8259A 中断控制芯片发出的硬件中断请求信号 IRQ0--IRQ15（见表 5–3 所示），并把用户程序发出的软件中断设置为 INT128（0x80），并称为系统调用（System Call）。系统调用中断是用户程序使用操作系统资源的唯一界面接口。

![1727429064044](assets/1727429064044.png)

在系统初始化时，内核会首先使用一个哑中断向量（中断描述符）对中断描述符表（Interrupt Descriptor Table - IDT）中所有 256 个描述符进行了默认设置。这个哑中断向量指向一个默认的“无中断”处理过程。





### 5.4.5标志寄存器的中断标志

为了避免竞争条件和中断对临界代码区的干扰，在 Linux 0.12 内核代码中许多地方使用了 cli 和 sti指令。

- cli 指令用来复位 CPU 标志寄存器中的中断标志，使得系统在执行 cli 指令后不会响应外部中断。
- sti 指令用来设置标志寄存器中的中断标志，以允许 CPU 能识别并响应外部设备发出的中断。

**当进入可能引起竞争条件的代码区时，内核中就会使用 cli 指令来关闭对外部中断的响应，而在执行完竞争代码区时内核就会执行 sti 指令以重新允许 CPU 响应外部中断。**







## 5.5 Linux 的系统调用

### 5.5.1系统调用接口

系统调用（通常称为 syscalls）是 Linux 内核与上层应用程序进行交互通信的唯一接口，参见图 5-4所示。从对中断机制的说明可知，用户程序通过直接或间接（通过库函数）调用中断 int 0x80，并在 eax寄存器中指定系统调用功能号，即可使用内核资源，包括系统硬件资源。不过通常应用程序都是使用具有标准接口定义的 C 函数库中的函数间接地使用内核的系统调用，见图 5-19 所示。

![1727429208301](assets/1727429208301.png)

通常系统调用使用函数形式进行调用，因此可带有一个或多个参数。对于系统调用执行的结果，它会在返回值中表示出来。通常负值表示错误，而 0 则表示成功。在出错的情况下，错误的类型码被存放在全局变量 errno 中。通过调用库函数 perror()，我们可以打印出该错误码对应的出错字符串信息。

在 Linux 内核中，每个系统调用都具有唯一的一个系统调用功能号。





### 5.5.2系统调用处理过程

当应用程序经过库函数向内核发出一个中断调用 `int 0x80` 时，就开始执行一个系统调用。其中`寄存器 eax` 中存放着系统调用号，而携带的参数可依次存放在`寄存器 ebx、ecx 和 edx `中。因此 Linux 0.12 内核中用户程序能够向内核最多直接传递三个参数，当然也可以不带参数。处理系统调用中断 `int 0x80` 的过程是程序`kernel/system_call.s` 中的 `system_call`。

为了方便执行系统调用，内核源代码在 `include/unistd.h` 文件（150—200 行）中定义了宏函数`_syscalln()`，其中 n 代表携带的参数个数，可以分别 0 至 3。因此最多可以直接传递 3 个参数。若需要传递大块数据给内核，则可以传递这块数据的指针值。例如对于 read()系统调用，其定义是：

```c
int read(int fd, char *buf, int n);
```

若我们在用户程序中直接执行对应的系统调用，那么该系统调用的宏的形式为：

```c
#define __LIBRARY__
#include <unistd.h>

_syscall3(int, read, int, fd, char *, buf, int, n)
```

因此我们可以在用户程序中直接使用上面的`_syscall3()`来执行一个系统调用 `read()`，而不用通过 C 函数库作中介。实际上 C 函数库中函数最终调用系统调用的形式和这里给出的完全一样。





如果有某个系统调用需要多于 3 个参数，那么内核通常采用的方法是直接把这些参数作为一个参数缓冲块，并把这个缓冲块的指针作为一个参数传递给内核。因此对于多于 3 个参数的系统调用，我们只需要使用带一个参数的宏`_syscall1()`，把第一个参数的指针传递给内核即可。

当进入内核中的系统调用处理程序 `kernel/sys_call.s` 后，`system_call `的代码会首先检查 `eax `中的系统调用功能号是否在有效系统调用号范围内，然后根据 `sys_call_table[]`函数指针表调用执行相应的系统调用处理程序。

```c
call _sys_call_table(,%eax,4)		// kernel/sys_call.s 第 99 行。
```





### 5.5.3Linux 系统调用的参数传递方式

关于 Linux 用户进程向系统中断调用过程传递参数方面，**Linux 系统使用了通用寄存器传递方法**，例如`寄存器 ebx、ecx 和 edx`。这种使用寄存器传递参数方法的一个明显优点就是：当进入系统中断服务程序而保存寄存器值时，这些传递参数的寄存器也被自动地放在了内核态堆栈上，因此用不着再专门对传递参数的寄存器进行特殊处理。







## 5.6 系统时间和定时

为了让操作系统能自动地准确提供当前时间和日期信息，PC/AT 微机系统中提供了用电池供电的实时钟 RT（Real Time）电路支持。通常这部分电路与保存系统信息的少量 CMOS RAM 集成在一个芯片上，因此这部分电路被称为 RT/CMOS RAM 电路。





### 5.6.2系统定时

系统的基本定时节拍由定时芯片产生。在 Linux 0.12 内核的初始化过程中，PC 机的可编程定时芯片Intel 8253（8254）的计数器通道 0 被设置成运行在方式 3 下（方波发生器方式），并且初始计数值 LATCH
被设置成每隔 10 毫秒在通道 0 输出端 OUT 发出一个方波上升沿。由于 8254 芯片的时钟输入频率为1.193180MHz，因此初始计数值 LATCH=1193180/100，约为 11931。由于 OUT 引脚被连接到可编程中断控制芯片的 0 级上，因此系统每隔 10 毫秒就会发出一个时钟中断请求（IRQ0）信号。**这个时间节拍就是操作系统运行的脉搏，我们称之为 1 个系统滴答或一个系统时钟周期。因此每经过 1 个滴答时间，系统就会调用一次时钟中断处理程序（timer_interrupt）。**

时钟中断处理程序timer_interrupt主要用来通过`jiffies` 变量来累计自系统启动以来经过的时钟滴答数。每当发生一次时钟中断 jiffies 值就增 1。然后调用 C 语言函数 do_timer()作进一步的处理。调用时所带的参数 CPL 是从被中断程序的段选择符（保存在堆栈中的 CS 段寄存器值）中取得当前代码特权级 CPL。







## 5.7 Linux 进程控制

**程序是一个可执行的文件，而进程（process）是一个执行中的程序实例。**利用分时技术，在 Linux
操作系统上同时可以运行多个进程。分时技术的基本原理是把 CPU 的运行时间划分成一个个规定长度的**时间片(time slice)**，让每个进程在一个时间片内运行。当进程的时间片用完时系统就利用调度程序切换到另一个进程去运行。

- 对于 Linux 0.12 内核来讲，系统最多可有 64 个进程同时存在。除了第一个进程用“手工”建立以外，其余的都是现有进程使用**系统调用 fork** 创建的新进程，被创建的进程称为**子进程（child process）**，创建者，则称为**父进程（parent process）**。
- 内核程序使用**进程标识号（process ID，pid）**来标识每个进程。
- **进程由可执行的指令代码、数据和堆栈区组成。**
- 进程中的代码和数据部分分别对应一个执行文件中的代码段、数据段。
- 每个进程只能执行自己的代码和访问自己的数据及堆栈区。
- 进程之间的通信需要通过系统调用来进行。



我们已经知道，Linux 系统中一个进程可以在**内核态（kernel mode）**或**用户态（user mode）**下执行，并且分别**使用各自独立的内核态堆栈和用户态堆栈**。

- **用户堆栈**用于进程在用户态下临时保存调用函数的参数、局部变量等数据；
- **内核堆栈**则含有内核程序执行函数调用时的信息。

另外在 Linux 内核中，进程通常被称作任务（task），而把运行在用户空间的程序称作进程。





### 5.7.1任务数据结构

**内核程序**通过**进程表**对进程进行管理，**每个进程在进程表中占有一项**。在 Linux 系统中，**进程表项**是一个 `task_struct `任务结构指针。任务数据结构定义在头文件 `include/linux/sched.h` 中。有些书上称其为**进程控制块 PCB（Process Control Block）**或进程描述符 PD（Processor Descriptor）。**其中保存着用于控制和管理进程的所有信息**。主要包括进程当前运行的状态信息、信号、进程号、父进程号、运行时间累计值、正在使用的文件和本任务的局部描述符以及任务状态段信息。该结构每个字段的具体含义如下所示。

```c
struct task_struct {
 long state; // 任务的运行状态（-1 不可运行，0 可运行(就绪)，>0 已停止）。
 long counter; // 任务运行时间计数(递减)（滴答数），运行时间片。
 long priority; // 优先数。任务开始运行时 counter=priority，越大运行越长。
 long signal; // 信号位图，每个比特位代表一种信号，信号值=位偏移值+1。
 struct sigaction sigaction[32]; // 信号执行属性结构，对应信号将要执行的操作和标志信息。
 long blocked; // 进程信号屏蔽码（对应信号位图）。
 int exit_code; // 任务停止执行后的退出码，其父进程会来取。
 unsigned long start_code; // 代码段地址。
 unsigned long end_code; // 代码长度（字节数）。
 unsigned long end_data; // 代码长度 + 数据长度（字节数）。
 unsigned long brk; // 总长度（字节数）。
 unsigned long start_stack; // 堆栈段地址。
 long pid; // 进程标识号(进程号)。
 long pgrp; // 进程组号。
 long session; // 会话号。
 long leader; // 会话首领。
 int groups[NGROUPS]; // 进程所属组号。一个进程可属于多个组。
 task_struct *p_pptr; // 指向父进程的指针。
 task_struct *p_cptr; // 指向最新子进程的指针。
 task_struct *p_ysptr; // 指向比自己后创建的相邻进程的指针。
 task_struct *p_osptr; // 指向比自己早创建的相邻进程的指针。
 unsigned short uid; // 用户标识号（用户 id）。
 unsigned short euid; // 有效用户 id。
 unsigned short suid; // 保存的用户 id。
 unsigned short gid; // 组标识号（组 id）。
 unsigned short egid; // 有效组 id。
 unsigned short sgid; // 保存的组 id。
 long timeout; // 内核定时器超时值。
 long alarm; // 报警定时值（滴答数）。
 long utime; // 用户态运行时间（滴答数）。
 long stime; // 系统态运行时间（滴答数）。
 long cutime; // 子进程用户态运行时间。
 long cstime; // 子进程系统态运行时间。
 long start_time; // 进程开始运行时刻。
 struct rlimit rlim[RLIM_NLIMITS]; // 进程资源使用统计数组。
 unsigned int flags; // 各进程的标志（还未使用）。
 unsigned short used_math; // 标志：是否使用了协处理器。
 int tty; // 进程使用 tty 终端的子设备号。-1 表示没有使用。
 unsigned short umask; // 文件创建属性屏蔽位。
 struct m_inode * pwd; // 当前工作目录 i 节点结构指针。
 struct m_inode * root; // 根目录 i 节点结构指针。
 struct m_inode * executable; // 执行文件 i 节点结构指针。
 struct m_inode * library; // 被加载库文件 i 节点结构指针。
 unsigned long close_on_exec; // 执行时关闭文件句柄位图标志。（参见 include/fcntl.h）
 struct file * filp[NR_OPEN]; // 文件结构指针表，最多 32 项。表项号即是文件描述符的值。
 struct desc_struct ldt[3]; // 局部描述符表。0-空，1-代码段 cs，2-数据和堆栈段 ds&ss。
 struct tss_struct tss; // 进程的任务状态段信息结构。
};
```

- `task_struct *p_pptr` 是指向父进程任务结构的指针。
- `task_struct *p_cptr` 是指向最新子进程任务结构的指针。
- `task_struct *p_ysptr` 是指向比自己后创建的相邻进程的指针。
- `task_struct *p_osptr` 是指向比自己早创建的相邻进程的指针。

以上 4 个指针的关系参见图 5-20 所示。

![1727430410850](assets/1727430410850.png)





当一个进程在执行时，**CPU 的所有寄存器中的值、进程的状态以及堆栈中的内容**被称为该**进程的上下文**。当内核需要切换（switch）至另一个进程时，它就需要保存当前进程的所有状态，也即保存当前进程的上下文，以便在再次执行该进程时，能够恢复到切换时的状态执行下去。在 Linux 中，当前进程上下文均保存在进程的任务数据结构中。在发生中断时，内核就在被中断进程的上下文中，在内核态下执行中断服务例程。但同时会保留所有需要用到的资源，以便中断服务结束时能恢复被中断进程的执行。





### 5.7.2进程运行状态

一个进程在其生存期内，可处于一组不同的状态下，称为**进程状态**。在某一时刻，Linux 下的一个进程可处于五种状态之一，见图 5-21 所示。图中每个含有不同数值的圆圈表示一种状态。如前可知，进程状态保存在进程任务结构的 state 字段中。

![1727430497579](assets/1727430497579.png)

Linux 的五种进程状态所用的常量符号名定义在文件 `include/linux/sched.h` 中第 46-50 行处。

```c
// 这里定义了进程运行时可能处的状态。
#define TASK_RUNNING 0 // 进程正在运行或已准备就绪。
#define TASK_INTERRUPTIBLE 1 // 进程处于可中断等待状态。
#define TASK_UNINTERRUPTIBLE 2 // 进程处于不可中断等待状态，主要用于 I/O 操作等待。
#define TASK_ZOMBIE 3 // 进程处于僵死状态，已经停止运行，但父进程还没发信号。
#define TASK_STOPPED 4 // 进程已停止。
```

**运行状态（0，TASK_RUNNING）**

- 当进程正在被 CPU 执行，或已经准备就绪随时可由调度程序执行，则称该进程为处于运行状态（running）。
- 若此时进程没有被 CPU 执行，则称其处于就绪状态。图 5-21 中间从上到下 3 个圆圈数值均为 0，都是就绪状态（运行状态）。
- 进程可以在**内核态运行**，也可以在**用户态运行**。
  - 当一个进程在内核代码中运行时，我们称其处于内核运行态，或简称为内核态；
  - 当一个进程正在执行用户自己的代码时，我们称其为处于用户运行态（用户态）。
- 当系统资源已经可用时，进程就被唤醒而进入准备运行状态，该状态称为就绪态。
- 这些状态（图中中间一列）在内核中表示方法相同，都被称为处于 **TASK_RUNNING 状态**。当一个新进程刚被创建出后就处于本状态中（最下一个 0 处）。



当一个进程的**运行时间片**用完，系统就会使用调度程序强制切换到其他的进程去执行。另外，如果进程在内核态执行时需要等待系统的某个资源，此时该进程就会调用 `sleep_on()`或` interruptible_sleep_on()`自 愿 地 放 弃 CPU 的 使 用 权 ， 而 让 调 度 程 序 去 执 行 其 他 进 程 。 进 程 则 进 入 睡 眠 状 态（TASK_UNINTERRUPTIBLE 或 TASK_INTERRUPTIBLE）。

只有当进程从“内核运行态”转移到“睡眠状态”时，内核才会进行进程切换操作。**在内核态下运行的进程不能被其他进程抢占，而且一个进程不能改变另一个进程的状态。为了避免进程切换时造成内核数据错误，内核在执行临界区代码时会禁止一切中断。**







### 5.7.3进程初始化

在 boot/目录中，引导程序把内核从磁盘上加载到内存中，并让系统进入保护模式下运行后，就开始
执行系统初始化程序 init/main.c。该程序首先确定如何分配使用系统物理内存，然后调用内核各部分的
初始化函数分别对内存管理、中断处理、块设备和字符设备、进程管理以及硬盘和软盘硬件进行初始化
处理。在完成了这些操作之后，系统各部分已经处于可运行状态。此后程序把自己“手工”移动到任务
0（进程 0）中运行，并使用 fork()调用首次创建出进程 1。在进程 1 中程序将继续进行应用环境的初始
化并执行 shell 登录程序。而原进程 0 则会在系统空闲时被调度执行，此时任务 0 仅执行 pause()系统调
用，其中又会去执行调度函数。

“移动到任务 0 中执行”这个过程由宏 move_to_user_mode（include/asm/system.h）完成。它把 main.c
程序执行流从内核态（特权级 0）移动到了用户态（特权级 3）的任务 0 中继续运行。在移动之前，系统
在对调度程序的初始化过程（sched_init()）中，首先对任务 0 的运行环境进行了设置。这包括人工预先
设置好任务 0 数据结构各字段的值（include/linux/sched.h）、在全局描述符表中添入任务 0 的任务状态段
（TSS）描述符和局部描述符表（LDT）的段描述符，并把它们分别加载到任务寄存器 tr 和局部描述符
表寄存器 ldtr 中。

这里需要强调的是，内核初始化是一个特殊过程，内核初始化代码也即是任务 0 的代码。从任务 0
数据结构中设置的初始数据可知，任务 0 的代码段和数据段的基址是 0、段限长是 640KB。而内核代码
段和数据段的基址是 0、段限长是 16MB，因此任务 0 的代码段和数据段分别包含在内核代码段和数据
段中。内核初始化程序 main.c 也即是任务 0 中的代码，只是在移动到任务 0 之前系统正以内核态特权级
0 运行着 main.c 程序。宏 move_to_user_mode 的功能就是把运行特权级从内核态的 0 级变换到用户态的
3 级，但是仍然继续执行原来的代码指令流。

在移动到任务 0 的过程中，宏 move_to_user_mode 使用了中断返回指令造成特权级改变的方法。使
用这种方法进行控制权转移是由 CPU 保护机制造成的。CPU 允许低级别（如特权级 3）代码通过调用门
或中断、陷阱门来调用或转移到高级别代码中运行，但反之则不行。因此内核采用了这种模拟 IRET 返
回低级别代码的方法。该方法的主要思想是在堆栈中构筑中断返回指令需要的内容，把返回地址的段选
择符设置成任务 0 代码段选择符，其特权级为 3。此后执行中断返回指令 iret 时将导致系统 CPU 从特权级 0 跳转到外层的特权级 3 上运行。参见图 5-22 所示的特权级发生变化时中断返回堆栈结构示意图。

![1727430866052](assets/1727430866052.png)

宏 move_to_user_mode 首先往内核堆栈中压入任务 0 堆栈段（即数据段）选择符和内核堆栈指针。
然后压入标志寄存器内容。最后压入任务 0 代码段选择符和执行中断返回后需要执行的下一条指令的偏
移位置。该偏移位置是 IRET 后的一条指令处。

当执行 iret 指令时，CPU 把返回地址送入 CS:EIP 中，同时弹出堆栈中标志寄存器内容。由于 CPU
判断出目的代码段的特权级是 3，与当前内核态的 0 级不同。于是 CPU 会把堆栈中的堆栈段选择符和堆
栈指针弹出到 SS:ESP 中。由于特权级发上了变化，段寄存器 DS、ES、FS 和 GS 的值变得无效，此时
CPU 会把这些段寄存器清零。因此在执行了 iret 指令后需要重新加载这些段寄存器。此后，系统就开始
以特权级3 运行在任务 0的代码上。此时原来在移动之前使用的堆栈就被当作任务 0的用户态堆栈使用。
而其内核态堆栈则由任务 0 的数据结构中 TSS 的内容指定。它被指定为其任务数据结构所在页面的顶端
开始（PAGE_SIZE + (long)&init_task）。由于以后在创建新进程时，需要复制任务 0 的任务数据结构，包
括其用户堆栈指针，因此要求任务 0 的用户态堆栈在创建任务 1（进程 1）之前保持“干净”状态。





### 5.7.4创建新进程

Linux 系统中创建新进程需要使用 fork()系统调用。系统正常运行起来后创建的所有进程都起源于进程 0，都是进程 0 的子进程。

在创建新进程的过程中，系统首先在任务数组中找出一个还没有被任何进程使用的空项（空槽）。如果系统已经有 64 个进程在运行，则 fork()系统调用会因为任务数组表中没有可用空项而出错返回。否则系统就会为新建进程在主内存区中申请一页内存来存放其任务数据结构信息，并复制当前进程任务数据结构中的所有内容作为新进程任务数据结构的模板。为了防止这个还未处理完成的新建进程被调度函数执行，此时应该立刻将新进程状态置为不可中断的等待状态（TASK_UNINTERRUPTIBLE）。

随后对复制的任务数据结构进行修改。把当前进程设置为新进程的父进程，清除信号位图并复位新进程各统计值，并设置初始运行时间片值为 15 个系统滴答数（150 毫秒）。接着根据当前进程设置任务状态段（TSS）中各寄存器的值。

此后系统设置新任务的代码和数据段基址、限长，并复制当前进程内存分页管理的页表。注意，此时系统并不为新的进程分配实际的物理内存页面，而是让它共享其父进程的内存页面。只有当父进程或新进程中任意一个有写内存操作时，系统才会为执行写操作的进程分配相关的独自使用的内存页面。这种处理方式称为**写时复制（Copy On Write）技术**。

随后，如果父进程中有文件是打开的，则应将对应文件的打开次数增 1。接着在 GDT 中设置新任务的 TSS 和 LDT 描述符项，其中基地址信息指向新进程任务结构中的 tss 和 ldt。最后再将新任务设置成可运行状态并返回新进程号。

另外请注意，**创建一个新的子进程和加载运行一个执行程序文件是两个不同的概念**。

- 当创建子进程时，它完全复制了父进程的代码和数据区，并会在其中执行子进程部分的代码。
- 而执行块设备上的一个程序时，一般是在子进程中运行 `exec()`系统调用来操作的。在进入 `exec()`后，子进程原来的代码和数据区就会被清掉（释放）。待该子进程开始运行新程序时，由于此时内核还没有从块设备上加载该程序的代码，CPU 就会立刻产生代码页面不存在的异常（Fault），此时内存管理程序就会从块设备上加载相应的代码页面，然后 CPU 又重新执行引起异常的指令。到此时新程序的代码才真正开始被执行。







### 5.7.5进程调度

**内核中的调度程序**用于选择系统中下一个要运行的进程。这种选择运行机制是多任务操作系统的基础。调度程序可以看作为在所有处于运行状态的进程之间分配 CPU 运行时间的管理代码。Linux 进程是抢占式的，但被抢占的进程仍然处于 TASK_RUNNING 状态，只是暂时没有被 CPU 运行。**进程的抢占发生在进程处于用户态执行阶段，在内核态执行时是不能被抢占的。**



**调度程序**

- schedule()函数首先扫描任务数组。通过比较每个就绪态（TASK_RUNNING）任务的运行时间递减滴答计数 counter 的值来确定当前哪个进程运行的时间最少。哪一个的值大，就表示运行时间还不长，于是就选中该进程，并使用任务切换宏函数切换到该进程运行。
- 如果此时所有处于 TASK_RUNNING 状态进程的时间片都已经用完，系统就会根据每个进程的优先权值 priority，对系统中所有进程（包括正在睡眠的进程）重新计算每个任务需要运行的时间片值 counter。
- 如果此时没有其他进程可运行，系统就会选择进程 0运行。对于 Linux 0.12 来说，进程 0会调用 pause()
  把自己置为可中断的睡眠状态并再次调用 schedule()。不过在调度进程运行时，schedule()并不在意进程 0处于什么状态。只要系统空闲就调度进程 0 运行。



**进程切换**

- 每当选择出一个新的可运行进程时，schedule()函数就会调用定义在` include/linux/sched.h` 中的`switch_to()`宏执行实际进程切换操作。该宏会把 CPU 的当前进程状态（上下文）替换成新进程的状态。
- 在进行切换之前，`switch_to()`首先检查要切换到的进程是否就是当前进程，如果是则什么也不做，直接退出。
- 否则就首先把内核全局变量 `current` 置为新任务的指针，然后长跳转到新任务的任务状态段 TSS组成的地址处，造成 CPU 执行任务切换操作。
- 此时 CPU 会把其所有寄存器的状态保存到当前任务寄存器 TR 中 TSS 段选择符所指向的当前进程任务数据结构的 tss 结构中，然后把新任务状态段选择符所指向的新任务数据结构中 tss 结构中的寄存器信息恢复到 CPU 中，系统就正式开始运行新切换的任务了。

这个过程可参见图 5-23 所示。

![1727431285306](assets/1727431285306.png)







### 5.7.6终止进程

当一个进程结束了运行或在半途中终止了运行，那么内核就需要释放该进程所占用的系统资源。这包括进程运行时打开的文件、申请的内存等。

当一个用户程序调用 exit()系统调用时，就会执行内核函数 do_exit()。该函数会首先释放进程代码段和数据段占用的内存页面，关闭进程打开着的所有文件，对进程使用的当前工作目录、根目录和运行程序的 i 节点进行同步操作。如果进程有子进程，则让 init 进程作为其所有子进程的父进程。如果进程是一个会话头进程并且有控制终端，则释放控制终端，并向属于该会话的所有进程发送挂断信号 SIGHUP，这通常会终止该会话中的所有进程。然后把进程状态置为僵死状态 TASK_ZOMBIE。并向其原父进程发送 SIGCHLD 信号，通知其某个子进程已经终止。最后 do_exit()调用调度函数去执行其他进程。由此可见在进程被终止时，它的任务数据结构仍然保留着。因为其父进程还需要使用其中的信息。

在子进程在执行期间，父进程通常使用 wait()或 waitpid()函数等待其某个子进程终止。当等待的子进程被终止并处于僵死状态时，父进程就会把子进程运行所使用的时间累加到自己进程中。最终释放已终止子进程任务数据结构所占用的内存页面，并置空子进程在任务数组中占用的指针项。









## 5.8 Linux 系统中堆栈的使用方法

Linux 0.12 系统中共使用了四种堆栈。

- 一种是**系统引导初始化时临时使用的堆栈**；
- 一种是**进入保护模式之后提供内核程序初始化使用的堆栈**，位于内核代码地址空间固定位置处。该堆栈也是后来**任务 0使用的用户态堆栈**；
- 另一种是每个任务通过系统调用，执行内核程序时使用的堆栈，我们称之为任务的**内核态堆栈**。每个任务都有自己独立的**内核态堆栈**；
- 最后一种是任务在**用户态执行的堆栈**，位于任务（进程）逻辑地址空间近末端处。



使用多个栈或在不同情况下使用不同栈的主要原因有两个。

- 首先是由于**从实模式进入保护模式，使得 CPU 对内存寻址访问方式发生了变化**，因此需要重新调整设置栈区域。
- 另外，为了**解决不同 CPU 特权级共享使用堆栈带来的保护问题，执行 0 级的内核代码和执行 3 级的用户代码需要使用不同的栈**。当一个任务进入内核态运行时，就会使用其 TSS 段中给出的特权级 0 的堆栈指针tss.ss0、tss.esp0，即内核栈。原用户栈指针会被保存在内核栈中。而当从内核态返回用户态时，就会恢复使用用户态的堆栈。







### 5.8.1初始化阶段

**开机初始化时(`bootsect.s，setup.s`)**

- 当 `bootsect` 代码被 ROM BIOS 引导加载到物理内存 `0x7c00` 处时，并没有设置堆栈段，当然程序也没有使用堆栈。直到 `bootsect` 被移动到 `0x9000:0` 处时，才把堆栈段寄存器 SS 设置为 0x9000，堆栈指针esp 寄存器设置为 `0xff00`，也即堆栈顶端在 `0x9000:0xff00` 处，参见` boot/bootsect.s `第 61、62 行。`setup.s`程序中也沿用了 `bootsect` 中设置的堆栈段。这就是**系统初始化时临时使用的堆栈**。





**进入保护模式时(head.s)**

- 从 `head.s` 程序起，系统开始正式在保护模式下运行。此时**堆栈段**被设置为`内核数据段（0x10）`，`堆栈指针 esp` 设置成指向 `user_stack` 数组的顶端（参见 head.s，第 31 行），保留了 1 页内存（4K）作为堆栈使用。
- `user_stack` 数组定义在` sched.c` 的 67--72 行，共含有 1024 个长字。它在物理内存中的位置示意图可参见下图 5-24 所示。**此时该堆栈是内核程序自己使用的堆栈**。
- 图中给出的地址是大约值，它们与编译时的实际设置参数有关。这些地址位置可从编译内核时生成的 `system.map` 文件中查到。

![1727576276465](assets/1727576276465.png)





**初始化时(main.c)**

- 在 `init/main.c` 程序中，在执行 `move_to_user_mode()`代码把控制权移交给任务 0 之前，系统一直使用上述堆栈。
- 而在执行过 `move_to_user_mode()`之后，`main.c` 的代码被“切换”成任务 0 中执行。通过执行`fork()`系统调用，`main.c` 中的 `init()`将在任务 1 中执行，并使用任务 1 的堆栈。而 `main()`本身则在被“切换”成为任务 0 后，仍然继续使用上述内核程序自己的堆栈作为任务 0 的用户态堆栈。







### 5.8.2任务的堆栈

每个任务都有两个堆栈，分别用于用户态和内核态程序的执行，并且分别称为用户态堆栈和内核态堆栈。除了处于不同 CPU 特权级中，这两个堆栈之间的主要区别在于任务的内核态堆栈很小，所保存的数据量最多不能超过（4096 – 任务数据结构块）个字节，大约为 3K 字节。而任务的用户态堆栈却可以在用户的 64MB 空间内延伸。



**在用户态运行时**

- 每个任务（除了任务 0 和任务 1）有自己的 64MB 地址空间。当一个任务（进程）刚被创建时，它的**用户态堆栈指针**被设置在其地址空间的靠近末端（64MB 顶端）部分。实际上末端部分还要包括执行程序的参数和环境变量，然后才是用户堆栈空间，见图 5-25 所示。
- 应用程序在用户态下运行时就一直使用这个堆栈。堆栈实际使用的物理内存则由 CPU 分页机制确定。
- 由于 Linux 实现了写时复制功能（Copy on Write），因此在进程被创建后，若该进程及其父进程都没有使用堆栈，则两者共享同一堆栈对应的物理内存页面。只有当其中一个进程执行堆栈写操作（例如 push 操作）时内核内存管理程序才会为写操作进程分配新的内存页面。而

![1727576552614](assets/1727576552614.png)







**在内核态运行时**

- 每个任务有其自己的内核态堆栈，用于任务在内核代码中执行期间。其所在线性地址中的位置由该任务 TSS 段中 ss0 和 esp0 两个字段指定。ss0 是任务内核态堆栈的段选择符，esp0 是堆栈栈低指针。因此每当任务从用户代码转移进入内核代码中执行时，任务的内核态栈总是空的。任务内核态堆栈被设置在位于其任务数据结构所在页面的末端，即与任务的任务数据结构（task_struct）放在同一页面内。这是在建立新任务时，fork()程序在任务tss段的内核级堆栈字段（tss.esp0和tss.ss0）中设置的，参见kernel/fork.c，92 行：
- 其中 p 是新任务的任务数据结构指针，tss 是任务状态段结构。内核为新任务申请内存用作保存其task_struct 结构数据，而 tss 结构（段）是 task_struct 中的一个字段。该任务的内核堆栈段值 tss.ss0 也被设置成为 0x10（即内核数据段选择符），而 tss.esp0 则指向保存 task_struct 结构页面的末端。见图 5-26所示。
-  Intel CPU 执行堆栈操作时是先递减堆栈指针 esp 值，然后在 esp 指针处保存入栈内容。
- 为什么从主内存区申请得来的用于保存任务数据结构的一页内存也能被设置成内核数据段中的数据呢，也即 tss.ss0 为什么能被设置成 0x10 呢？这是因为用户内核态栈仍然属于内核数据空间。我们可以从内核代码段的长度范围来说明。在 head.s 程序的末端，分别设置了内核代码段和数据段的描述符，段长度都被设置成了 16MB。这个长度值是 Linux 0.12 内核所能支持的最大物理内存长度（参见 head.s，110行开始的注释）。因此，内核代码可以寻址到整个物理内存范围中的任何位置，当然也包括主内存区。每当任务执行内核程序而需要使用其内核栈时，CPU 就会利用 TSS 结构把它的内核态堆栈设置成由tss.ss0 和 tss.esp0 这两个值构成。在任务切换时，老任务的内核栈指针 esp0 不会被保存。对 CPU 来讲，这两个值是只读的。因此每当一个任务进入内核态执行时，其内核态堆栈总是空的。

![1727576642613](assets/1727576642613.png)







**任务 0 和任务 1 的堆栈**

- 任务 0（空闲进程 idle）和任务 1（初始化进程 init）的堆栈比较特殊，需要特别予以说明。任务 0和任务 1 的代码段和数据段相同，限长也都是 640KB，但它们被映射到不同的线性地址范围中。任务 0的段基地址从线性地址 0 开始，而任务 1 的段基地址从 64MB 开始。但是它们全都映射到物理地址0--640KB 范 围 中 。 这 个 地 址 范 围 也 就 是 内 核 代 码 和 基 本 数 据 所 存 放 的 地 方 。 在执行了move_to_user_mode()之后，任务 0 和任务 1 的内核态堆栈分别位于各自任务数据结构所在页面的末端，而任务 0 的用户态堆栈就是前面进入保护模式后所使用的堆栈，即 sched.c 的 user_stack[]数组的位置。由于任务 1 在创建时复制了任务 0 的用户堆栈，因此刚开始时任务 0 和任务 1 共享使用同一个用户堆栈空间。但是当任务 1 开始运行时，由于任务 1 映射到 user_stack[]处的页表项被设置成只读，使得任务 1在执行堆栈操作时将会引起写页面异常，从而内核会使用写时复制机制2为任务 1 另行分配主内存区页面作为堆栈空间使用。只有到此时，任务 1 才开始使用自己独立的用户堆栈内存页面。因此任务 0 的堆栈需要在任务 1 实际开始使用之前保持“干净”，即任务 0 此时不能使用堆栈，以确保复制的堆栈页面中不含有任务 0 的数据。
- 任务 0 的内核态堆栈是在其人工设置的初始化任务数据结构中指定的，而它的用户态堆栈是在执行`move_to_user_mode()`时，在模拟 `iret` 返回之前的堆栈中设置的，参见图 5-22 所示。







### 5.8.3任务内核态堆栈与用户态堆栈之间的切换

在 Linux 0.12 系统中，所有中断服务程序都属于内核代码。如果一个中断产生时任务正在用户代码中执行，那么该中断就会引起 CPU 特权级从 3 级到 0 级的变化，此时 CPU 就会进行用户态堆栈到内核态堆栈的切换操作。CPU 会从当前任务的任务状态段 TSS 中取得新堆栈的段选择符和偏移值。因为中断服务程序在内核中，属于 0 级特权级代码，所以 48 比特的内核态堆栈指针会从 TSS 的 ss0 和 esp0 字段中获得。在定位了新堆栈（内核态堆栈）之后，CPU 就会首先把原用户态堆栈指针 ss 和 esp 压入内核态堆栈，随后把标志寄存器 eflags 的内容和返回位置 cs、eip 压入内核态堆栈。

内核的系统调用是一个软件中断，因此任务调用系统调用时就会进入内核并执行内核中的中断服务代码。此时内核代码就会使用该任务的内核态堆栈进行操作。同样，当进入内核程序时，由于特权级别发生了改变（从用户态转到内核态），用户态堆栈的堆栈段和堆栈指针以及 eflags 会被保存在任务的内核态堆栈中。而在执行 iret 退出内核程序返回到用户程序时，将恢复用户态的堆栈和 eflags。这个过程见图5-27 所示。

![1727576824077](assets/1727576824077.png)

如果一个任务正在内核态中运行，那么若 CPU 响应中断就不再需要进行堆栈切换操作，因为此时该任务运行的内核代码已经在使用内核态堆栈，并且不涉及优先级别的变化，所以 CPU 仅把 eflags 和中断返回指针 cs、eip 压入当前内核态堆栈，然后执行中断服务过程。







## 5.9 Linux 0.12 采用的文件系统

内核代码若要正常运行就需要文件系统的支持。用于向内核提供最基本信息和支持的是**根文件系统**，即 Linux 系统引导启动时，默认使用的文件系统是根文件系统。其中包括操作系统最起码的一些配置文件和命令执行程序。对于 **Linux 系统中使用的 UNIX 类文件系统，其中主要包括一些规定的目录、配置文件、设备驱动程序、开发程序以及所有其他用户数据或文本文件等**。一般都包括以下一些子目录和文件：

```bash
etc/ 目录主要含有一些系统配置文件；
dev/ 含有设备特殊文件，用于文件操作语句操作设备；
bin/ 存放系统执行程序。例如 sh、mkfs、fdisk 等；
usr/ 存放库函数、手册和其他一些文件；
usr/bin 存放用户常用的普通命令；
var/ 用于存放系统运行时可变的数据或者是日志等信息。
```

存放文件系统的设备就是**文件系统设备**。比如，对于一般使用的 Windows 10 操作系统，硬盘 C 盘就是文件系统设备，而硬盘上按一定规则存放的文件就组成文件系统。Windows 10 有 NTFS、FAT32 等不同格式的文件系统，Linux 同样也有 EXT2、EXT3 等多种不同格式的文件系统可供选择使用。而 Linux0.12 内核所支持的文件系统是简单的 MINIX 1.0 文件系统。目前 Linux 系统上使用最广泛的则是 ext3 或ext4 文件系统。

Linux 0.12 系统，它由简单的 2 张软盘组成：`bootimage 盘`和`rootimage 盘`。

- `bootimage` 是**引导启动 Image 文件**，其中主要包括磁盘引导扇区代码、操作系统加载程序和内核执行代码。
- `rootimage` 就是用于向内核提供最基本支持的**根文件系统**。

当 Linux 启动盘加载根文件系统时，会根据启动盘上引导扇区第 509、510 字节处一个字（ROOT_DEV）中的根文件系统设备号从指定的设备中加载根文件系统。如果这个设备号是 0 的话，则表示需要从引导盘所在当前驱动器中加载根文件系统。若该设备号是一个硬盘分区设备号的话，就会从该指定硬盘分区中加载根文件系统。











## 5.10 Linux 内核源代码的目录结构

由于 Linux 内核是一种**单内核模式**的系统，因此，内核中所有的程序几乎都有紧密的联系。它们之间的数据和信息依赖和调用关系非常密切

使用 tar 命令将压缩的内核源代码文件 linux-0.12.tar.gz 解开时，文件被放到了 linux/目录中。其中的目录结构见图 5-28 所示：

![1727577154241](assets/1727577154241.png)





### 5.10.1 内核主目录 linux

linux 目录是源代码的主目录。在该主目录中除了包括所有的 14 个子目录以外，还含有唯一的一个`Makefile` 文件。该文件是编译辅助工具软件 make 的参数配置文件。m

linux 目录下的这个 Makefile 文件还嵌套地调用了所有子目录中包含的 Makefile 文件，这样，当 linux目录（包括子目录）下的任何文件被修改过时，make 都会对其进行重新编译。因此为了编译整个内核所有的源代码文件，只要在 linux 目录下运行一次 make 软件即可。





### 5.10.2 引导启动程序目录 boot

boot 目录中含有 3 个汇编语言文件，是内核源代码文件中最先被编译的程序。这 3 个程序完成的主要功能是当计算机加电时引导内核启动，将内核代码加载到内存中，并做一些进入 32 位保护运行方式前的系统初始化工作。

- `bootsect.s` 程序是磁盘引导块程序，编译后会驻留在磁盘的第一个扇区中（引导扇区，0 磁道（柱
  面），0 磁头，第 1 个扇区）。在 PC 机加电 ROM BIOS 自检后，将被 BIOS 加载到内存 0x7C00
  处进行执行。
- `setup.s`程序主要用于读取机器的硬件配置参数，并把内核模块system移动到适当的内存位置处。
- `head.s` 程序会被编译连接在 system 模块的最前部分，主要进行硬件设备的探测设置和内存管理
  页面的初始设置工作。

其中 `bootsect.s` 和 `setup.s` 程序需要使用 as86 软件来编译，使用的是 as86 的汇编语言格式，而 `head.s` 需要用 GNU as 来编译，使用的是 AT&T 格式的汇编语言。





### 5.10.3 文件系统目录 fs

Linux 0.12 内核的文件系统采用了 1.0 版的 MINIX 文件系统，这是由于 Linux 是在 MINIX 系统上开发的。采用 MINIX 文件系统便于进行交叉编译，并且可以从 MINIX 中加载 Linux 分区。由于采用了多线程处理方式，Linux 程序就必须处理多线程带来的竞争条件、死锁等问题，因此 Linux 文件系统代码要比 MINIX 系统的复杂得多。为了避免竞争条件的发生，Linux 系统对资源分配进行了严格地检查，并且**在内核模式下运行时，如果任务没有主动睡眠（调用 sleep()），就不让内核切换任务。**



**`fs/`目录是文件系统实现程序的目录**，共包含 18 个 C 语言程序。这些程序之间的主要引用和依赖关系见图 5-29 所示。图中每个方框代表一个文件，从上到下按基本引用关系放置。其中各文件名均略去了后缀.c，虚框中的程序文件不属于文件系统，带箭头的线条表示引用关系，粗线条表示有相互引用关系。

![1727577501978](assets/1727577501978.png)

由图可以看出，该目录中的程序可以划分成四个部分：高速缓冲区管理、低层文件操作、文件数据访问和文件高层函数。

**对于文件系统，我们可以将它看成是内存高速缓冲区的扩展部分。所有对文件系统中数据的访问，都需要首先读取到高速缓冲区中。**本目录中的程序主要用来管理高速缓冲区中缓冲块的使用分配和块设备上的文件系统。**管理高速缓冲区的程序是 `buffer.c`，而其他程序则主要都是用于文件系统管理。**

虚框中的 `ll_rw_block` 是块设备的底层读函数，它并不在 `fs` 目录中，而是 `kernel/blk_drv/ll_rw_block.c`中的块设备读写驱动函数。放在这里只是让我们清楚的看到，文件系统对于块设备中数据的读写，都需要通过高速缓冲区与块设备的驱动程序（`ll_rw_block()`）来操作来进行，文件系统程序集本身并不直接与块设备的驱动程序打交道。





### 5.10.4 头文件主目录 include

头文件目录中总共有 36 个.h 头文件。其中主目录下有 13 个，asm 子目录中有 4 个，linux 子目录中有 11 个，sys 子目录中有 8 个。

-  a.out 头文件，定义了 a.out 执行文件格式和一些宏。



**include/asm -- 体系结构相关头文件子目录**

- 这些头文件主要定义了一些与 CPU 体系结构密切相关的数据结构、宏函数和变量。共 4 个文件。



**include/linux -- Linux 内核专用头文件子目录**



**include/sys -- 系统专用数据结构子目录**









### 5.10.5 Init -- 内核初始化程序目录

该目录中仅包含一个文件 `main.c`，用于**执行内核所有的初始化工作。然后执行权移到用户模式创建新进程，并在控制台设备上运行 shell 程序**。









### 5.10.6 Kernel -- 内核程序主目录

`linux/kernel` 目录下共有 32 个文件和 3 个子目录（`blk_drv、chr_drv 和 math`）。其中 kernel 目录下有12 个代码文件和一个 Makefile 文件，子目录 kernel/blk_drv 下有 5 个文件，子目录 kernel/chr_drv 下有 6个文件，子目录 kernel/math 下有 9 个文件。

所有**处理任务的程序**都保存在 kernel/目录中，其中包括象 `fork`、`exit`、**调度程序**以及一些**系统调用程序**等。还包括**处理中断异常**和**陷阱的处理过程**。子目录中包括了低层的**设备驱动程序**，如 get_hd_block和 tty_write 等。见图 5-30 所示。

![1727577925518](assets/1727577925518.png)





**`kernel/blk_drv` -- 块设备驱动程序子目录**

通常情况下，**用户通过文件系统来访问设备，而设备驱动程序为文件系统实现了调用接口**。在使用块设备时，由于其数据吞吐量大，为了能够高效率地使用块设备上的数据，在**用户进程**与**块设备**之间使用了**高速缓冲机制**。在访问块设备上的数据时，系统首先以数据块的形式把块设备上的数据读入到**高速缓冲区**中，然后再提供给用户。`blk_drv` 子目录共包含 4 个 c 文件和 1 个头文件。见图 5-31 所示。

![1727577979257](assets/1727577979257.png)





**kernel/chr_drv -- 字符设备驱动程序子目录**

字符设备程序子目录共含有 4 个 C 语言程序和 2 个汇编程序文件。这些文件实现了对串行端口 rs-232、串行终端、键盘和控制台终端设备的驱动。图 5-32 是这些文件之间的大致调用层次关系。

![1727578117288](assets/1727578117288.png)





**kernel/math -- 协处理器仿真和操作程序子目**

该子目录中含有数学协处理器仿真处理程序文件，共有 9 个 C 文件。









### 5.10.7 Lib -- 内核库函数目录

与普通用户程序不同，内核代码不能使用标准 C 函数库及其他一些函数库。主要原因是由于完整的C 函数库很大。**因此在内核源代码中有专门一个 lib/目录提供内核需要用到的一些函数。内核函数库用于为内核初始化程序 init/main.c 运行在用户态的进程（进程 0、1）提供调用支持。**

在 lib/目录中共有 12 个 C 语言文件。除了一个由 tytso 编制的 malloc.c 程序较长以外，其他的程序很短，有的只有一二行代码。它们实现了一些系统调用的接口函数。这些文件中主要包括有退出函数_exit()、关闭文件函数 close(fd)、复制文件描述符函数 dup()、文件打开函数 open()、写文件函数 write()、执行程序函数 execve()、内存分配函数 malloc()、等待子进程状态函数 wait()、创建会话系统调用 setsid()以及在 include/string.h 中实现的所有字符串操作函数。







### 5.10.8 Mm -- 内存管理程序目录

该目录包括 3 个代码文件。**主要用于管理程序对主内存区的使用，实现了进程逻辑地址到线性地址以及线性地址到物理内存地址的映射操作。**并通过内存分页管理机制，在进程的虚拟内存页与主内存区的物理内存页之间建立了对应关系。同时还真正实现了虚拟存储技术。

Linux 内核对内存的处理使用了分段和分页两种方式。

- 首先是将 80X86 的 4G 虚拟地址空间分割成64 个段(每个段 64MB)。**内核程序占用其中第一个段，并且物理地址与该段线性地址相同。**
- 然后每个任务分配一个段使用。**分页机制**用于把指定的物理内存页面映射到段内，检测 fork创建的任何重复的拷贝，并执行**写时复制机制**。



各个文件作用：

- `page.s` 文件包括内存页面异常中断（int 14）处理程序，主要用于处理程序由于缺页而引起的页异常中断和访问非法地址而引起的页保护。
- `memory.c` 程序包括对内存进行初始化的函数 mem_init()，由 page.s 的内存处理中断过程调用的`do_no_page()`和 `do_wp_page()`函数。在创建新进程而执行复制进程操作时，即使用该文件中的内存处理函数来分配管理内存空间。
- `swap.c` 程序用于管理主内存中物理页面和高速二级存储（硬盘）空间之间的页面交换。当主内存空间不够用时就可以先把暂时不用的内存页面保存到硬盘中。当发生缺页异常时就首先在硬盘中查看要求的页面是否在交换空间中，若存在则把页面从交换空间直接读入内存中。







### 5.10.9 Tools -- 编译内核工具程序目录

该目录下的 build.c 程序用于构建完整的内核模块。它将 Linux 目录中被分别编译生成的目标代码连接合并成一个可运行的内核映像文件 image。









## 5.11 内核与应用程序的关系

在 Linux 系统中，表面来看内核可从两个方面为用户程序提供服务支持。其一是通过系统调用接口，也即中断调用 int 0x80；另一方面是通过开发环境库函数或内核库函数。不过内核库函数仅供内核创建的任务 0 和任务 1 使用。它们最终还是去调用系统调用。**因此内核对所有用户程序或进程实际上只提供系统调用这一种统一的服务接口。**

**系统调用**主要用于系统软件编程，或用于库函数的实现。而一般用户开发的程序则是通过调用象 `libc`等库中函数来访问内核资源。这些库中的函数或资源通常被称为应用程序编成接口（API）。其中定义了应用程序使用的一组标准编成接口。通过调用这些库中的函数，应用程序代码能够完成各种常见工作。

在 UNIX 类操作系统中，最为普遍使用的是**基于 POSIX 标准的 API 接口**。Linux 当然也不例外。API与系统调用的区别在于：为了实现某一应用程序接口标准，例如 POSIX，其中的 **API 可以与一个系统调用对应，也可能由几个系统调用的功能共同实现**。当然**某些 API 函数可能根本就不需要使用系统调用，即不使用内核功能**。无论两个操作系统提供的系统调用有多么大的区别，但只要它们都**遵循同一个 API 标准，那么应用程序就可以在这些操作系统之间具有可移植性。**

**系统调用是内核与外界接口的最高层。在内核中，每个系统调用常以宏的形式实现，并且都有一个序列号**（在 `include/unistd.h` 头文件中定义）。**应用程序不应该直接使用内核系统调用，否侧程序的移植性就变差了**。









## 5.12 linux/Makefile 文件

### 5.12.1 功能描述

Makefile 文件相当于程序编译过程中的批处理文件，是工具程序 make 运行时默认的编译设置输入文件。只要在含有 Makefile 的当前目录中键入 make 命令，它就会依据 Makefile 文件中的设置调用编译程序和链接程序对源程序或目标代码文件进行编译、链接，或对编译链接结果进行安装等活动。

内核目录中这个 Makefile 文件的主要作用是指示 make 程序最终使用独立编译连接成的 tools/目录中
的 build 可执行程序将所有内核编译代码连接和合并成一个可运行的内核映像文件 image。具体过程是：
（1）首先是对 boot/中的 bootsect.s、setup.s 使用 8086 汇编器进行编译，分别生成各自的执行模块。（2）
再对源代码中的其他所有程序使用 GNU 的编译器 gcc/gas 进行编译，并链接生成模块 system。（3）最后
再用 build 工具将这三块组合成一个内核映像文件 image。

build 是由 tools/build.c 源程序编译而成的一个独立的可执行程序，它本身并没有被编译链接到内核
代码中，仅作为构建内核映像文件过程中的一个工具使用。基本编译链接/组合结构如图 5-33 所示。

![1727578884202](assets/1727578884202.png)


































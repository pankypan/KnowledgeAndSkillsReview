# 4 80X86 保护模式及其编程

## 4.1 80X86 系统寄存器和系统指令

**为了协助处理器执行初始化和控制系统操作**，80X86 提供了**一个标志寄存器 EFLAGS** 和几个**系统寄存器**，除了一些通用状态标志外，EFLAGS 中还包含几个系统标志。这些系统标志用于控制任务切换、中断处理、指令跟踪以及访问权限。系统寄存器用于内存管理和控制处理器操作，含有分段和分页处理机制系统表的基地址、控制处理器操作的比特标志位。





### 4.1.1标志寄存器

**标志寄存器 EFLAGS** 中的系统标志和 IOPL 字段用于控制 I/O 访问、可屏蔽硬件中断、调试、任务切换以及虚拟-8086 模式，见图 4-1 所示。通常只允许操作系统代码有权修改这些标志。EFLAGS 中的其他标志是一些通用标志（进位 CF、奇偶 PF、辅助进位 AF、零标志 ZF、负号 SF、方向 DF、溢出 OF）。

![1727579237286](assets/1727579237286.png)







### 4.1.2内存管理寄存器

**处理器提供了 4 个内存管理寄存器（GDTR、LDTR、IDTR 和 TR）**，用于指定内存分段管理所用系统表的基地址，见图 4-2 所示。处理器为这些寄存器的加载和保存提供了特定的指令。

![1727579279723](assets/1727579279723.png)

- 全局描述符表寄存器 GDTR
  - **GDTR 寄存器**中用于存放**全局描述符表 GDT 的 32 位的线性基地址和 16 位的表限长值**。基地址指定GDT 表中字节 0 在线性地址空间中的地址，表长度指明 GDT 表的字节长度值。指令 LGDT 和 SGDT 分别用于加载和保存 GDTR 寄存器的内容。
- 中断描述符表寄存器 IDTR
  - 与 GDTR 的作用类似，**IDTR 寄存器**用于存放**中断描述符表 IDT 的 32 位线性基地址和 16 位表长度值**。指令 LIDT 和 SIDT 分别用于加载和保存 IDTR 寄存器的内容。
- 局部描述符表寄存器 LDTR
  - **LDTR 寄存器**中用于存放局部描述符表 LDT 的 32 位线性基地址、16 位段限长和描述符属性值。指令LLDT 和 SLDT 分别用于加载和保存 LDTR 寄存器的段描述符部分。包含 LDT 表的段必须在 GDT 表中有一个段描述符项。
  - 当进行任务切换时，处理器会把新任务 LDT的段选择符和段描述符自动地加载进 LDTR 中。
- 任务寄存器 TR
  - TR 寄存器用于存放当前任务 TSS 段的 16 位段选择符、32 位基地址、16 位段长度和描述符属性值。它引用 GDT 表中的一个 TSS 类型的描述符。指令 LTR 和 STR 分别用于加载和保存 TR 寄存器的段选择符部分。
  - 当执行任务切换时，处理器会把新任务的 TSS 的段选择符和段描述符自动地加载进任务寄存器 TR 中。







### 4.1.3控制寄存器

**控制寄存器（CR0、CR1、CR2 和 CR3）**用于控制和确定处理器的操作模式以及当前执行任务的特性，见图 4-3 所示。

![1727579458610](assets/1727579458610.png)

- CR0 中协处理器控制位

  - CR0 的 4 个比特位：扩展类型位 ET、任务切换位 TS、仿真位 EM 和数学存在位 MP 用于控制 80X86浮点（数学）协处理器的操作。

- **CR0 中保护控制位**

  - **PE**：CR0 的位 0 是启用保护（Protection Enable）标志。当设置该位时即开启了保护模式；当复位时即
    进入实地址模式。
  - **PG：** CR0 的位 31 是分页（Paging）标志。当设置该位时即开启了分页机制；当复位时则禁止分页机制，此时所有线性地址等同于物理地址。在开启这个标志之前必须已经或者同时开启 PE 标志。即若要启用分页机制，那么 PE 和 PG 标志都要置位。
  - **WP：** 对于 Intel 80486 或以上的 CPU，CR0 的位 16 是写保护（Write Proctect）标志。当设置该标志时，处理器会禁止超级用户程序（例如特权级 0 的程序）向用户级只读页面执行写操作；

  启用保护模式 PE（Protected Enable）位（位 0）和开启分页 PG（Paging）位（位 31）分别用于控制分段和分页机制。

  如果 PE=0、PG=0，处理器工作在实地址模式下；如果 PG=0、PE=1，处理器工作在没有开启分页机制的保护模式下；如果 PG=1、PE=0，此时由于不在保护模式下不能启用分页机制，因此处理器会产生一个一般保护异常，即这种标志组合无效；如果 PG=1、PE=1，则处理器工作在开启了分页机制的保护模式下。

  **当改变 PE 和 PG 位时，我们必须小心。只有当执行程序起码有部分代码和数据在线性地址空间和物理地址空间中具有相同地址时，我们才能改变 PG 位的设置。**此时这部分具有相同地址的代码在分页和未分页世界之间起着桥梁的作用。无论是否开启分页机制，这部分代码都具有相同的地址。另外，在开启分页（PG=1）之前必须先刷新页高速缓冲 TLB。

  **在修改该了 PE 位之后程序必须立刻使用一条跳转指令，以刷新处理器执行管道中已经获取的不同模式下的任何指令。**在设置 PE 位之前，程序必须初始化几个系统段和控制寄存器。

- CR2 和 CR3

  - **CR2 和 CR3 用于分页机制**。**CR3 含有存放页目录表页面的物理地址，因此 CR3 也被称为 PDBR**。因为页目录表页面是页对齐的，所以该寄存器只有高 20 位是有效的。而







### 4.1.4系统指令

系统指令用于处理系统级功能，例如加载系统寄存器、管理中断等。大多数系统指令只能由处于特权级 0 的操作系统软件执行，其余一些指令可以在任何特权级上执行，因此应用程序也能使用。表 4-2 中列出了我们将用到的一些系统指令。

![1727579774529](assets/1727579774529.png)

![1727579788956](assets/1727579788956.png)









## 4.2 保护模式内存管理

### 4.2.1内存寻址

**内存是指一组有序字节组成的数组，每个字节有唯一的内存地址**。

**内存寻址**则是指对存储在内存中的某个指定数据对象的**地址进行定位**。通常内存地址从 0 开始编址，对于 80X86 CPU 来说，其**地址总线宽度为 32 位**，因此一共有 2^32 个不同物理地址。即内存物理地址空间有 4G，总共**可以**
**寻址 4G 字节的物理内存**。对于多字节数据类型（例如 2 字节整数数据类型），在内存中这些字节相邻存放。80X86 首先存放低值字节，随后地址处存放高值字节。因此 80X86 CPU 是一种**先存小值（Little Endium）**的处理器。

对于 80X86 CPU，**一条指令**主要由**操作码（Opcode）**和操作对象即**操作数（Oprand）**构成。操作数可以位于一个寄存器中，也可以在内存中。

为了进行内存寻址，80X86 使用了一种称为**段（Segment）的寻址技术**。这种寻址技术把内存空间分成一个或多个称为段的线性区域，从而对内存中一个数据对象的寻址就需要使用一个**段的起始地址（即段地址）**和**一个段内偏移地址**两部分构成。

80X86 为段部分提供了 6 个**存放段选择符的段寄存器**：CS、DS、ES、SS、FS 和 GS。

- 其中 **CS 总是用于寻址代码段**，而**堆栈段则专门使用 SS 段寄存器**。在任何指定时刻由 CS 寻址的段称为当前代码段。此时**EIP 寄存器中包含了当前代码段内下一条要执行指令的段内偏移地址**。因此**要执行指令的地址可表示成`CS:[EIP]`**。
- 由段寄存器SS寻址的段称为当前堆栈段。栈顶由ESP寄存器内容指定。因此堆栈顶处地址是SS:[ESP]。
- 当指令中没有指定所操作数据的段时，那么 DS 将是默认的数据段寄存器



指令的偏移量由三部分相加组成：基地址寄存器、变址寄存器和一个偏移常量。即：
`偏移地址 = 基地址 + （变址 x 比例因子） + 偏移量`





### 4.2.2地址变换

任何完整的内存管理系统都包含两个关键部分：**保护和地址变换**。提供保护措施可以防止一个任务访问另一个任务或操作系统的内存区域。地址变换能够让操作系统在给任务分配内存时具有灵活性，并且因为我们可以让某些物理地址不被任何逻辑地址所映射，所以在地址变换过程中同时也提供了内存保护功能。

计算机中的物理内存是字节的线性数组，每个字节具有一个唯一的物理地址；**程序中的地址**是由两部分构成的**逻辑地制**。这种逻辑地址并不能直接用于访问物理内存，而需要使用地址变换机制将它变换或映射到物理内存地址上。

为了减少确定地址变换所需要的信息，变换或映射通常以内存块作为操作单位。**分段机制和分页机制**是两种广泛使用的**地址变换技术**。分段和分页操作都使用**驻留在内存中的表**来指定它们各自的**变换信息**。这些表只能由操作系统访问，以防止应用程序擅自修改。

80X86 在从逻辑地址到物理地址变换过程中使用了分段和分页两种机制，见图 4-4 所示。

![1727580374720](assets/1727580374720.png)



**分段机制**

- 分段提供了隔绝各个代码、数据和堆栈区域的机制，因此多个程序（或任务）可以运行在同一个处理器上而不会互相干扰。
- 如图 4-5 所示，分段提供了一种机制，用于把处理器可寻址的线性地址空间划分成一些较小的称为段的受保护地址空间区域。段可以用来存放程序的代码、数据和堆栈，或者用来存放系统数据结构（例如 TSS或 LDT）。如果处理器中有多个程序或任务在运行，那么每个程序可分配各自的一套段。此时处理器就可以加强这些段之间的界限，并且确保一个程序不会通过访问另一个程序的段而干扰程序的执行。
- 一个系统中所有使用的段都包含在处理器线性地址空间中。为了定位指定段中的一个字节，程序必须提供一个逻辑地址。逻辑地址包括一个段选择符和一个偏移量。段选择符是一个段的唯一标识。另外，段选择符提供了段描述符表（例如全局描述符表 GDT）中一个数据结构（称为段描述符）的偏移量。**每个段都有一个段描述符**。段描述符指明段的大小、访问权限和段的特权级、段类型以及段的第 1 个字节在线性地址空间中的位置（称为段的基地址）。
- **虚拟地址（逻辑地址）空间**可包含最多 16K 的段，而每个段最长可达 4GB，使得虚拟地址空间容量达到 64TB（246）。**线性地址空间和物理地址空间都是 4GB**（2^32）。实际上，**如果禁用分页机制，那么线性地址空间就是物理地址空间。**

![1727580595179](assets/1727580595179.png)





**分页机制**

- 虚拟存储是一种内存管理技术，使用这种技术可让编程人员产生内存空间要比计算机中实际物理内存容量大很多的错觉。利用这种错觉，我们可以随意编制大型程序而无需考虑实际物理内存究竟有多少。
- 当使用分页时，每个段被划分成**页面**（通常每页为 4KB 大小），页面会被存储于物理内存中或硬盘上。**操作系统通过维护一个页目录和一些页表**来留意这些页面。当程序（或任务）试图访问线性地址空间中的一个地址位置时，处理器就会使用**页目录和页表**把线性地址转换成一个物理地址，然后在该内存位置上执行所要求的操作（读或写）。
- 如果当前被访问的页面不在物理内存中，处理器就会中断程序的执行（通过产生一个**页错误异常**）。然后操作系统就可以从硬盘上把该页面读入物理内存中，并继续执行刚才被中断的程序。当操作系统严格实现了分页机制时，那么对于正确执行的程序来说页面在物理内存和硬盘之间的交换就是透明的。
- 0X86 分页机制最适合支持虚拟存储技术。分页机制会使用大小固定的内存块，而分段管理则使用了大小可变的块来管理内存。无论在物理内存中还是在硬盘上，分页使用固定大小的块更为适合管理物理内存。





分段和分页是两种不同的地址变换机制，它们都对整个地址变换操作提供独立的处理阶段。尽管两种机制都使用存储在内存中的变换表，但所用的表结构不同。实际上，段表存储在线性地址空间，而页表则保存在物理地址空间。段变换机制把虚拟地址（逻辑地址）变换成线性地址，并且在线性地址空间中访问自己的表，但是并不知晓分页机制把这些线性地址转换到物理地址的过程。类似地，分页机制也不知道程序产生地址的虚拟地址空间。分页机制只是简单地把线性地址转换成物理地址，并且在物理内存中访问自己的转换表。







### 4.2.3保护

80X86 支持两类保护。

- 其一是通过**给每个任务不同的虚拟地址（逻辑地址）空间来完全隔离各个任务**。其实现原理是向每个任务提供不同的逻辑地址到物理地址的变换映射。
- 另一个保护机制对任务进行操作，以保护操作系统内存段和处理器特殊系统寄存器不被应用程序访问。





**任务之间的保护**

- 80X86 使用的方法是通过**把每个任务放置在不同的虚拟地址空间中，并给予每个任务不同的逻辑地址到物理地址的变换映射**。每个任务中的地址变换功能被定义成一个任务中的逻辑地址映射到物理内存的一部分区域，而另一个任务中的逻辑地址映射到物理内存中的不同区域中。这样，因为一个任务不可能生成能够映射到其他任务逻辑地址对应使用的物理内存部分，所以所有任务都被隔绝开了。**只需给每个任务各自独立的映射表，每个任务就会有不同的地址变换函数。**
- 在 80X86 中，**每个任务都有自己的段表和页表**。当处理器切换去执行一个新任务时，**任务切换的关键部分就是切换到新任务的变换表。**
- 通过在所有任务中安排具有相同的虚拟到物理地址映射部分，并且把操作系统存储在这个公共的虚拟地址空间部分，操作系统可以被所有任务共享。**这个所有任务都具有的相同虚拟地址空间部分被称为全局地址空间（Global address space）**。这也正是现代 Linux 操作系统使用虚拟地址空间的方式。
- **每个任务唯一的虚拟地址空间部分被称为局部地址空间（Local address space）**。局部地址空间含有需
  要与系统中其他任务区别开的私有的代码和数据。由于每个任务中具有不同的局部地址空间，因此两个不同任务中对相同虚拟地址处的引用将转换到不同的物理地址处。这使得操作系统可以给与每个任务的内存相同的虚拟地址，但仍然能隔绝每个任务。另一方面，**所有任务在全局地址空间中对相同虚拟地址的引用将被转换到同一个物理地址处**。这给公共代码和数据（例如操作系统）的共享提供了支持。





**特权级保护**

- 在一个任务中，定义了 4 个执行特权级（Privilege Levels），用于依据段中含有数据的敏感度以及任务中不同程序部分的受信程度，来限制对任务中各段的访问。
- 特权级用数字 0 到 3 表示，0 具有最高特权级，而 3 则是最低特权级。每个内存段都与一个特权级相关联。这个特权级限制具有足够特权级的程序来访问一个段。我们知道，处理器从 CS 寄存器指定的段中取得和执行指令，当前特权级（Current Privilege Level），即 CPL 就是当前活动代码段的特权级，并且它定义了当前所执行程序的特权级别。CPL 确定了哪些段能够被程序访问。
- 每当程序企图访问一个段时，当前特权级就会与段的特权级进行比较，以确定是否有访问许可。在给定 CPL 级别上执行的程序允许访问同级别或低级别的数据段。任何对高级别段的引用都是非法的，并且会引发一个异常来通知操作系统。
- 每个特权级都有自己的程序栈，以避免使用共享栈带来的保护问题。当程序从一个特权级切换到另一个特权级上执行时，堆栈段也随之改换到新级别的堆栈中。









## 4.3 分段机制

### 4.3.1段的定义

保护模式中 80X86 提供了 4GB 的物理地址空间。这是处理器在其地址总线上可以寻址的地址空间。这个地址空间是平坦的，地址范围从 0 到 0xFFFFFFFF。这个物理地址空间可以映射到读写内存、只读内存以及内存映射 I/O 中。**分段机制就是把虚拟地址空间中的虚拟内存组织成一些长度可变的称为段的内存块单元。**

段是**虚拟地址**到**线性地址**转换机制的基础。每个段由三个参数定义：

- **段基地址（Base address）**，指定段在**线性地址空间**中的开始地址。**基地址是线性地址，对应于段中偏移 0 处。**
- 段限长（limit），是虚拟地址空间中段内最大可用偏移位置。它定义了段的长度。
- 段属性（Attributes），指定段的特性。例如该段是否可读、可写或可作为一个程序执行；段的特权级等。



见图 4-6 所示。在本书介绍的 Linux 0.1x 系统中，一个任务的**代码段**和**数据段**的段限长相同，并被映射到线性地址完全相同而重叠的区域上。

![1727582106907](assets/1727582106907.png)

段的基地址、段限长以及段的保护属性存储在一个称为**段描述符（Segment Descriptor）**的结构项中。

**逻辑地址由 16 位的段选择符和 32 位的偏移量组成**，见图 4-7 所示。段选择符指定字节所在的段，而偏移量指定该字节在段中相对于段基地址的位置。处理器会把每个逻辑地址转换成线性地址。线性地址是处理器线性地址空间中的32 位地址。与物理地址空间类似，**线性地址空间也是平坦的 4GB 地址空间**，地址范围从 `0 到0xFFFFFFFF`。

为了把逻辑地址转换成一个线性地址，处理器会执行以下操作：

1. 使用段选择符中的偏移值（段索引）在 GDT 或 LDT 表中定位相应的段描述符。（仅当一个新的段选择符加载到段寄存器中时才需要这一步。）
2. 利用段描述符检验段的访问权限和范围，以确保该段是可访问的并且偏移量位于段界限内。
3. 把段描述符中取得的段基地址加到偏移量上，最后形成一个线性地址。

![1727582242808](assets/1727582242808.png)

如果没有开启分页，那么处理器直接把线性地址映射到物理地址。如果对线性地址空间进行了分页处理，那么就会使用二级地址转换把线性地址转换成物理地址。









### 4.3.2段描述符表

段描述符表是段描述符的一个数组，见图 4-8 所示。有两种描述符表：**全局描述符表 GDT**（Global descriptor table）；**局部描述符表 LDT**（Local descriptor table）。

![1727582318655](assets/1727582318655.png)

描述符表存储在由操作系统维护着的特殊数据结构中，并且由处理器的内存管理硬件来引用。这些特殊结构应该保存在仅由操作系统软件访问的受保护的内存区域中，以防止应用程序修改其中的地址转换信息。**虚拟地址空间被分割成大小相等的两半。一半由 GDT 来映射变换到线性地址，另一半则由 LDT 来映射。**整个虚拟地址空间共含有 214个段：

- 一半空间（即 213 个段）是由 GDT 映射的全局虚拟地址空间
- 另一半是由 LDT 映射的局部虚拟地址空间。

当发生任务切换时，LDT 会更换成新任务的 LDT，但是 GDT 并不会改变。因此，GDT 所映射的一半虚拟地址空间是系统中所有任务共有的，但是 LDT 所映射的另一半则在任务切换时被改变。系统中所有任务共享的段由 GDT 来映射。

图 4-9 示出一个任务中的段如何能在 GDT 和 LDT 之间分开。

![1727582450761](assets/1727582450761.png)

当任务 A 在运行时，可访问的段包括 LDTA映射的 CodeA和 DataA段，加上 GDT 映射的操作系统的段 CodeOS 和 DataOS。当任务 B 在运行时，可访问的段包括 LDTB映射的 CodeB和 DataB段，加上 GDT 映射的段。



**GDT:**

- **每个系统必须定义一个 GDT，并可用于系统中所有程序或任务。**另外，**可选定义一个或多个 LDT**。例如，可以为每个运行任务定义一个 LDT，或者某些或所有任务共享一个 LDT。
- **GDT** 本身并不是一个段，而**是线性地址空间中的一个数据结构**。**GDT 的基线性地址和长度值必须加载进 GDTR 寄存器中。**GDT 的基地址应该进行内存 8 字节对齐，以得到最佳处理器性能。
- 因为段描述符总是 8 字节长，因此 **GDT** 的限长值应该设置成总是 8 的倍数减 1（即 8N-1）。处理器并不使用 GDT 中的第 1 个描述符。



**LDT:**

- **LDT 表存放在 LDT 类型的系统段中。此时 GDT 必须含有 LDT 的段描述符。**
- 如果系统支持多 LDT 的话，那么每个 LDT 都必须在 GDT 中有一个段描述符和段选择符。一个 LDT 的段描述符可以存放在 GDT表的任何地方。
- 访问 LDT 需使用其段选择符。为了在访问 LDT 时减少地址转换次数，LDT 的段选择符、基地址、段限长以及访问权限需要存放在 **LDTR 寄存器**中。







### 4.3.3段选择符

**段选择符（或称段选择子）是段的一个 16 位标识符**，见图 4-10 所示。段选择符并不直接指向段，而是**指向**段描述符表中定义段的**段描述符**。

**段选择符 3 个字段内容：**

- 请求特权级 RPL（Requested Privilege Level）；
- 表指示标志 TI（Table Index）；
- 索引值（Index）。

![1727582819916](assets/1727582819916.png)



对应用程序来说段选择符是作为指针变量的一部分而可见，但**选择符的值通常是由链接编辑器或链接加载程序进行设置或修改，而非应用程序。**



为减少地址转换时间和编程复杂性，处理器提供可存放最多 6 个段选择符的寄存器（见图 4-12 所示），即**段寄存器**。每个段寄存器支持特定类型的内存引用（代码、数据或堆栈）。**原则上执行每个程序都起码需要把有效的段选择符加载到代码段（CS）、数据段（DS）和堆栈段（SS）寄存器中。**处理器还另外提供三个辅助的数据段寄存器（ES、FS 和 GS），可被用于让当前执行程序（或任务）能够访问其他几个数据段。

![1727583008434](assets/1727583008434.png)

对于访问某个段的程序，必须已经把段选择符加载到一个段寄存器中。

另外，为了避免每次访问内存时都去引用描述符表，去读和解码一个段描述符，每个段寄存器都有一个“可见”部分和一个“隐藏”部分（隐藏部分也被称为“**描述符缓冲**”或“影子寄存器”）。当一个段选择符被加载到一个段寄存器可见部分中时，处理器也同时把段选择符指向的段描述符中的段地址、段限长以及访问控制信息加载到段寄存器的隐藏部分中。缓冲在段寄存器（可见和隐藏部分）中的信息使得处理器可以在进行地址转换时不再需要花费时间从段描述符中读取基地址和限长值。



为加载段寄存器，提供了两类加载指令：

1. 象 `MOV、POP、LDS、LES、LSS、LGS 以及 LFS 指令`。这些指令显式地直接引用段寄存器；
2. 隐式加载指令，例如使用长指针的 `CALL、JMP 和 RET 指令、IRET、INTn、INTO 和 INT3 等指令`。这些指令在操作过程中会附带改变 CS 寄存器（和某些其他段寄存器）的内容。







### 4.3.4段描述符

段描述符是 GDT 和 LDT 表中的一个数据结构项，用于向处理器提供有关一个段的位置和大小信息以及访问控制的状态信息。

**每个段描述符长度是 8 字节，含有三个主要字段：段基地址、段限长和段属性。**

**段描述符通常由编译器、链接器、加载器或者操作系统来创建，但绝不是应用程序。**

图 4-13 示出了所有类型段描述符的一般格式。

![1727583176970](assets/1727583176970.png)







### 4.3.6系统描述符类型

**当段描述符中的 S 标志（描述符类型）是复位状态（0）的话，那么该描述符是一个系统描述符。**处理器能够识别以下一些类型的系统段描述符：

局部描述符表（LDT）的段描述符；

- 任务状态段（TSS）描述符；
- 调用门描述符；
- 中断门描述符；
- 陷阱门描述符；
- 任务门描述符。

这些描述符类型可分为两大类：**系统段描述符**和**门描述符**。

- 系统段描述符指向系统段（如 LDT 和 TSS段）
- 门描述符就是一个“门”，
  - 对于调用、中断或陷阱门，其中含有代码段的选择符和段中程序入口点的指针；
  - 对于任务门，其中含有 TSS 的段选择符。

表 4-4 给出了系统段描述符和门描述符类型字段的编码。

![1727583383250](assets/1727583383250.png)

![1727583393596](assets/1727583393596.png)











## 4.4 分页机制

处理器**分页机制**会把线性地址空间（段已映射到其中）划分成页面，然后这些线性地址空间页面被映射到物理地址空间的页面上。分页机制几种页面级保护措施，可和分段机制保护机制合用或替代分段机制的保护措施。另外，在页面单元上，分页机制还提供了用户 - 超级用户两级保护。

我们通过设置控制寄存器 CR0 的 PG 位可以启用分页机制。如果 PG=1，则启用分页操作，处理器会使用本节描述的机制将线性地址转换成物理地址。如果 PG=0，则禁用分页机制，此时分段机制产生的线性地址被直接用作物理地址。

分页机制对固定大小的内存块（称为页面）进行操作。分页机制把线性和物理地址空间都划分成页面。线性地址空间中的任何页面可以被映射到物理地址空间的任何页面上。图 4-16 示出了分页机制是如何把线性和物理地址空间都划分成各个页面，并在这两个空间之间提供了任意映射。

![1727590486242](assets/1727590486242.png)

80X86 使用 4K（2^12）字节固定大小的页面。每个页面均是 4KB，并且对齐于 4K 地址边界处。由于 4K 大小的页面作为一个单元进行映射，并且对齐于 4K 边界，因此线性地址的低 12 比特位可作为页内偏移量直接作为物理地址的低 12 位。分页机制执行的重定位功能可以看作是把线性地址的高 20 位转换到对应物理地址的高 20 位。

另外，线性到物理地址的转换功能被扩展成允许一个线性地址被标注为无效的，而非让其产生一个物理地址。在两种情况下一个页面可以被标注为无效的：

- ①操作系统不支持的线性地址；
  - 在第一种情况下，产生无效地址的程序必须被终止。
- ②对应在虚拟内存系统中的页面在磁盘上而非在物理内存中。
  - 在第二种情况下，该无效地址实际上是请求操作系统虚拟内存管理器把对应页面从磁盘上加载到物理内存中，以供程序访问。

因为无效页面通常与虚拟存储系统相关，因此它们被称为不存在的页面，并且由页表中称为存在（present）的属性来确定。

当使用分页时，处理器会把线性地址空间划分成固定大小的页面（长度 4KB），这些页面可以映射到物理内存中和/或磁盘存储空间中。当一个程序（或任务）引用内存中的逻辑地址时，处理器会把该逻辑地址转换成一个线性地址，然后使用分页机制把该线性地址转换成对应的物理地址。

如果包含线性地址的页面当前不在物理内存中，处理器就会产生一个页错误异常。页错误异常的处理程序通常就会让操作系统从磁盘中把相应页面加载到物理内存中（操作过程中可能还会把物理内存中不同的页面写到磁盘上）。当页面加载到物理内存中之后，从异常处理过程的返回操作会使得导致异常的指令被重新执行。处理器用于把线性地址转换成物理地址和用于产生页错误异常（若必要的话）的信息包含在存储于内存中的页目录和页表中。

分页与分段最大的不同之处在于分页使用了固定长度的页面。但如果使用了分页，那么一个数据结构就可以一部分存储于物理内存中，而另一部分保存在磁盘中。

为了减少地址转换所要求的总线周期数量，最近访问的页目录和页表会被存放在处理器的缓冲器件中，该缓冲器件被称为**转换查找缓冲区 TLB（Translation Lookaside Buffer）**。TLB 可以满足大多数读页目录和页表的请求而无需使用总线周期。







### 4.4.1页表结构

分页转换功能由驻留在内存中的表来描述，该表称为**页表（page table），存放在物理地址空间中**。

**页表**中每个**页表项大小为 32 位。**由于只需要**其中的 20 位来存放页面的物理基地址**，因此剩下的 12位可用于存放诸如页面是否存在等的属性信息。如果线性地址索引的页表项被标注为存在的，则表示该项即有效，我们可以从中取得页面的物理地址。如果项中表明不存在，那么当访问对应物理页面时就会产生一个异常。





#### 4.4.1.1 两级页表结构

因此为了减少内存占用量，80X86 使用了两级表。由此，高 20 位线性地址到物理地址的转换也被分成两步来进行，每步使用（转换）其中 10 个比特。

第一级表称为**页目录（page directory）**。它被存放在 1 页 4K 页面中，具有 210（1K）个 4 字节长度的表项。这些表项指向对应的二级表。线性地址的最高 10 位（位 31--22）用作一级表（页目录）中的索引值来选择 2^10个二级表之一。

第二级表称为**页表（page table）**，它的长度也是 1 个页面，最多含有 1K 个 4 字节的表项。每个 4 字节表项含有相关页面的 20 位物理基地址。二级页表使用线性地址中间 10 位（位 21--12）作为表项索引值，以获取含有页面 20 位物理基地址的表项。

图 4-17 示出了二级表的查找过程。其中 **CR3 寄存器**指定页目录表的基地址。

![1727591057273](assets/1727591057273.png)





#### 4.4.1.2 不存在的页表

**目录表页面必须总是存在于物理内存中，但是二级页表可以在需要时再分配**。这使得页表结构的大小对应于实际使用的线性地址空间大小。

页目录表中每个表项也有一个存在（present）属性，类似于页表中的表项。页目录表项中的存在属性指明对应的二级页表是否存在。如果目录表项指明对应的二级页表存在，那么通过访问二级表，表查找过程第 2 步将同如上描述继续下去。如果存在位表明对应的二级表不存在，那么处理器就会产生一个异常来通知操作系统。页目录表项中的存在属性使得操作系统可以根据实际使用的线性地址范围来分配二级页表页面。

目录表项中的存在位还可以用于在虚拟内存中存放二级页表。这意味着在任何时候只有部分二级页表需要存放在物理内存中，而其余的可保存在磁盘上。处于物理内存中页表对应的页目录项将被标注为存在，以表明可用它们进行分页转换。处于磁盘上的页表对应的页目录项将被标注为不存在。由于二级页表不存在而引发的异常会通知操作系统把缺少的页表从磁盘上加载进物理内存。把页表存储在虚拟内存中减少了保存分页转换表所需要的物理内存量。





### 4.4.2页表项格式

页目录和页表的**表项格式**见图 4-18 所示。其中位 31--12 含有**物理地址的高 20 位**，用于定位物理地址空间中一个页面（也称为页帧）的**物理基地址**。表项的低 12 位含有**页属性信息**。

![1727591248336](assets/1727591248336.png)







### 4.4.3虚拟存储

**页目录和页表表项中的存在标志 P** 为使用**分页技术的虚拟存储**提供了必要的支持。若线性地址空间中的页面存在于物理内存中，则对应表项中的标志 P=1，并且该表项中含有相应物理地址。页面不在物理内存中的表项其标志 P = 0。如果程序访问物理内存中不存在的页面，处理器就会产生一个缺页异常。此时操作系统就可以利用这个异常处理过程把缺少的页面从磁盘上调入物理内存中，并把相应物理地址存放在表项中。最后在返回程序重新执行引起异常的指令之前设置标志 P=1。

已访问标志 A 和已修改标志 D 可以用于有效地实现虚拟存储技术。通过周期性地检查和复位所有 A标志，操作系统能够确定哪些页面最近没有访问过。











## 4.5 保护

保护机制是可靠的多任务运行环境所必须的。它可用于保护各个任务免受相互之间的干扰。

保护机制可以被用于分段和分页机制。**处理器寄存器的 2 个比特位定义了当前执行程序的特权级，称为当前特权级 CPL（Current Privilege Level）**。在分段和分页地址转换过程中，处理器将对 CPL 进行验证。

通过设置**控制寄存器 CR0 的 PE 标志（位 0）**可以让处理器工作在**保护模式**下，从而也就开启了分段保护机制。

设置控制寄存器 CR0 的 PG 标志（位 31）可以开启分页机制，同时也开启了分页保护机制。

对于分段级保护机制，处理器使用**段寄存器中选择符（RPL 和 CPL）**和**段描述符中各个字段**执行保护验证。

对于分页机制，则主要利用**页目录和页表项中的 R/W 和 U/S 标志**来实现保护操作。







### 4.5.1段级保护

当使用保护机制时，每个内存引用都将受到检察以验证内存引用符合各种保护要求。因为检查操作是与地址变换同时并行操作，所以处理器性能并没有受到影响。所进行的**保护检查**可分为以下几类：

- 段界限检查；
- 段类型检查；
- 特权级检查；
- 可寻址范围限制；
- 过程入口点限制；
- 指令集限制。

所有违反保护的操作都将导致产生一个异常。





#### 4.5.1.1 段限长 Limit 检查

段描述符的段限长（或称段界限）字段用于防止程序或过程寻址到段外内存位置。





#### 4.5.1.2 段类型 TYPE 检查

除了应用程序代码和数据段有描述符以外，处理器还有系统段和门两种描述符类型。这些数据结构用于管理任务以及异常和中断。请注意，并非所有的描述符都定义一个段，门描述符中存放有指向一个过程入口点的指针。**段描述符在两个地方含有类型信息，即描述符中的 S 标志和类型字段 TYPE。处理器利用这些信息对由于非法使用段或门导致的编程错误进行检测。**









#### 4.5.1.3 特权级

处理器的段保护机制可以识别 4 个特权级（或特权层），0 级到 3 级。数值越大，特权越小。图 4-19示出了这些特权级如何能被解释成保护环形式。环中心（保留给最高级的代码、数据和堆栈）用于含有最紧要软件的段，通常用于操作系统核心部分。中间两个环用于较为紧要的软件。只使用 2 个特权级的系统应该使用特权级 0 和 3。

![1727592150601](assets/1727592150601.png)

处理器利用特权级来防止运行在较低特权级的程序或任务访问具有较高特权级的一个段，除非是在受控的条件下。当处理器检测到一个违反特权级的操作时，它就会产生一个一般保护性异常。



为了在各个代码段和数据段之间进行特权级检测处理，处理器可以识别以下三种类型的特权级：

- 当前特权级 CPL（Current Privilege Level）。CPL 是当前正在执行程序或任务的特权级。它存放在CS 和 SS 段寄存器的位 0 和位 1 中。通常，CPL 等于当前代码段的特权级。
- 描述符特权级 DPL（Descriptor Privilege Level）。DPL 是一个段或门的特权级。它存放在段或门描述符的 DPL 字段中。
- 请求特权级 RPL（Request Privilege Level）。RPL 是一种赋予段选择符的超越特权级，它存放在选择符的位 0 和位 1 中。处理器会同时检查 RPL 和 CPL，以确定是否允许访问一个段。

当段描述符的段选择符被加载进一个段寄存器时就会进行特权级检查操作，但用于数据访问的检查方式和那些用于在代码段之间进行程序控制转移的检查方式不一样。







### 4.5.2访问数据段时的特权级检查

为了访问数据段中的操作数，数据段的**段选择符**必须被加载进**数据段寄存器（DS、ES、FS 或 GS）**或**堆栈段寄存器（SS）**中。（可以使用指令 MOV、POP、LDS、LES、LFS、LGS 和 LSS 来加载段寄存器）。在把一个段选择符加载进段寄存器中之前，处理器会进行特权级检查，见图 4-20 所示。它会把当前运行程序或任务的 CPL、段选择符的 RPL 和段描述符的 DPL 进行比较。只有当段的 DPL 数值大于或等于 CPL和 RPL 两者时，处理器才会把选择符加载进段寄存器中。否则就会产生一个一般保护异常，并且不加载段选择符。

![1727592316901](assets/1727592316901.png)

可知一个程序或任务可寻址的区域随着其 CPL 改变而变化。当 CPL 是 0 时，此时所有特权级上的数据段都可被访问；当 CPL 是 1 时，只有在特权级 1 到 3 的数据段可被访问；当 CPL 是 3 时，只有处于特权级 3 的数据段可被访问。







### 4.5.3代码段之间转移控制时的特权级检查

对于将程序控制权从一个代码段转移到另一个代码段，目标代码段的段选择符必须加载进代码段寄存器（CS）中。作为这个加载过程的一部分，处理器会检测目标代码段的段描述符并执行各种限长、类型和特权级检查。如果这些检查都通过了，则目标代码段选择符就会加载进 CS 寄存器，于是程序的控制权就被转移到新代码段中，程序将从 EIP 寄存器指向的指令处开始执行。

程序的控制转移使用指令 JMP、RET、INT 和 IRET 以及异常和中断机制来实现。

JMP 或 CALL 指令可以利用一下四种方法之一来引用另外一个代码段：

- 目标操作数含有目标代码段的段选择符；
- 目标操作数指向一个调用门描述符，而该描述符中含有目标代码段的选择符；
- 目标操作数指向一个 TSS，而该 TSS 中含有目标代码段的选择符；
- 目标操作数指向一个任务门，该任务门指向一个 TSS，而该 TSS 中含有目标代码段的选择符；





#### 4.5.3.1 直接调用或跳转到代码段

JMP、CALL 和 RET 指令的近转移形式只是在当前代码段中执行程序控制转移，因此不会执行特权级检查。JMP、CALL 或 RET 指令的远转移形式会把控制转移到另外一个代码段中，因此处理器一定会执行之醒特权级检查。

当不通过调用门把程序控制权转移到另一个代码段时，处理器会验证 4 种特权级和类型信息，见图 4-21所示：

![1727592505908](assets/1727592505908.png)

- 当前特权级 CPL。（这里，CPL 是执行调用的代码段的特权级，即含有执行调用或跳转程序的代码段的 CPL。）
- 含有被调用过程的目的代码段段描述符中的描述符特权级 DPL。
- 目的代码段的段选择符中的请求特权级 RPL。
- 目的代码段描述符中的一致性标志 C。它确定了一个代码段是非一致代码段还是一致代码段。





#### 4.5.3.2 门描述符

为了对具有不同特权级的代码段提供受控的访问，处理器提供了称为门描述符的特殊描述符集。共有4 种**门描述符**：

- 调用门（Call Gate），类型 TYPE=12；
- 陷阱门（Trap Gate），类型 TYPE=15；
- 中断门（Interrupt Gate），类型 TYPE=14；
- 任务门（Task Gate），类型 TYPE=5。

任务门用于任务切换。陷阱门和中断门是调用门的特殊类，专门用于调用异常和中断的处理程序



**调用门用于在不同特权级之间实现受控的程序控制转移。**它们通常仅用于使用特权级保护机制的操作系统中。图 4-22 给出了调用门描述符的格式。调用门描述符可以存放在 GDT 或 LDT 中，但是不能放在中断描述符表 IDT 中。一个调用门主要具有一下几个功能：

- 指定要访问的代码段；
- 在指定代码段中定义过程（程序）的一个入口点；
-  指定访问过程的调用者需具备的特权级；
- 若会发生堆栈切换，它会指定在堆栈之间需要复制的可选参数个数；
- 指明调用门描述符是否有效。

![1727592682123](assets/1727592682123.png)

调用门中的段选择符字段指定要访问的代码段。偏移值字段指定段中入口点。这个入口点通常是指定过程的第一条指令。DPL 字段指定调用门的特权级，从而指定通过调用门访问特定过程所要求的特权级。标志 P 指明调用门描述符是否有效。





#### 4.5.3.3 通过调用门访问代码段

**为了访问调用门，我们需要为 CALL 或 JMP 指令的操作数提供一个远指针。**该指针中的段选择符用于指定调用门，而指针的偏移值虽然需要但 CPU 并不会用它。该偏移值可以设置为任意值。见图 4-23 所示。

当处理器访问调用门时，它会使用调用门中的段选择符来定位目的代码段的段描述符。然后 CPU 会把代码段描述符的基地址与调用门中的偏移值进行组合，形成代码段中指定程序入口点的线性地址。

![1727592785643](assets/1727592785643.png)







通过调用门进行程序控制转移时，CPU 会对 4 中不同的特权级进行检查，以确定控制转移的有效性，见图 4-24 所示。

- 当前特权级 CPL；
- 调用门选择符中的请求特权级 RPL；
- 调用门描述符中的描述符特权级 DPL；
- 目的代码段描述符中的 DPL；

另外，目的代码段描述符中的一致性标志 C 也将受到检查。

![1727592886850](assets/1727592886850.png)







使用 CALL 指令和 JMP 指令分别具有不同的特权级检测规则，见表 4-5 所示。

![1727592920377](assets/1727592920377.png)







#### 4.5.3.4 堆栈切换

每当调用门用于把程序控制转移到一个更高级别的非一致性代码段时，CPU 会自动切换到目的代码段特权级的堆栈去。执行栈切换操作的目的是为了防止高特权级程序由于栈空间不足而引起崩溃，同时也为了防止低特权级程序通过共享的堆栈有意或无意地干扰高特权级的程序。

每个任务必须定义最多 4 个栈。一个用于运行在特权级 3 的应用程序代码，其他分别用于用到的特权级 2、1 和 0。如果一个系统中只使用了 3 和 0 两个特权级，那么每个任务就只需设置两个栈。每个栈都位于不同的段中，并且使用段选择符和段中偏移值指定。

当特权级 3 的程序在执行时，特权级 3 的堆栈的段选择符和栈指针会被分别存放在 SS 和 ESP 中，并且在发生堆栈切换时被保存在被调用过程的堆栈上。

特权级 0、1 和 2 的堆栈的初始指针值都存放在当前运行任务的 TSS 段中。TSS 段中这些指针都是只读值。



操作系统需要负责为所有用到的特权级建立堆栈和堆栈段描述符，并且在任务的 TSS 中设置初始指针值。每个栈必须可读可写，并且具有足够的空间来存放以下一些信息：

- 调用过程的 SS、ESP、CS 和 EIP 寄存器内容；
- 被调用过程的参数和临时变量所需使用的空间。
- 当隐含调用一个异常或中断过程时标志寄存器 EFLAGS 和出错码使用的空间。





当通过调用门执行一个过程调用而造成特权级改变时，CPU 就会执行以下步骤切换堆栈并开始在新的特权级上执行被调用过程（见图 4-25 所示）：

![1727593037207](assets/1727593037207.png)









#### 4.5.3.5 从被调用过程返回

指令 RET 用于执行近返回（near return）、同特权级远返回（far return）和不同特权级的远返回。该指令用于从使用 CALL 指令调用的过程中返回。近返回仅在当前代码段中转移程序控制权，因此 CPU 仅进行界限检查。对于相同特权级的远返回，CPU 同时从堆栈中弹出返回代码段的选择符和返回指令指针。由于通常情况下这两个指针是 CALL 指令压入栈中的，因此它们应该是有效的。但是 CPU 还是会执行特权级检查以应付当前过程可能修改指针值或者堆栈出现问题时的情况。









### 4.5.4 页级保护

页目录和页表表项中的读写标志 R/W 和用户/超级用户标志U/S 提供了分段机制保护属性的一个子集。分页机制只识别两级权限。特权级 0、1 和 2 被归类为超级用户级，而特权级 3 被作为普通用户级。普通用户级的页面可以被标志成只读/可执行或可读/可写/可执行。超级用户级的页面对于超级用户来讲总是可读/可写/可执行的，但普通用户不可访问，见表 4-6 所示。

![1727593130645](assets/1727593130645.png)





#### 4.5.4.1 修改页表项的软件问题

为了避免每次内存应用都要访问驻留内存的页表，从而加快速度，最近使用的线性到物理地址的转换信息被保存在**处理器内的页转换高速缓冲**中。处理器在访问内存中的页表之前会首先利用缓冲中的信息。只有当必要的转换信息不在高速缓冲中时，处理器才会搜寻内存中的页目录和页表。页转换高速缓冲的另一个术语称为**转换查找缓冲 TLB（Translation Lookaside Buffer）**







### 4.5.5组合页级和段级保护

当启用了分页机制，CPU 会首先执行段级保护，然后再处理页级保护。如果 CPU 在任何一级检测到一个保护违规错误，则会放弃内存访问并产生一个异常。

页级保护不能替代或忽略段级保护。









## 4.6 中断和异常处理

**中断（Interrupt）**和**异常（Exception）**是指明系统、处理器或当前执行程序（或任务）的某处出现一个事件，该事件需要处理器进行处理。通常，这种事件会导致执行控制被强迫从当前运行程序转移到被称为中断处理程序（interrupt handler）或异常处理程序（exception handler）的特殊软件函数或任务中。

- **中断发生在程序执行的随机时刻，以响应硬件发出的信号**。系统硬件使用中断来处理外部事件，例如要求为外部设备提供服务。当然，软件也能通过执行 `INT n` 指令产生中断。
- **异常发生在处理器执行一条指令时，检测到一个出错条件时发生**，例如被 0 除出错条件。处理器可以
  检测到各种出错条件，包括违反保护机制、页错误以及机器内部错误。





### 4.6.1异常和中断向量

为了有助于处理异常和中断，每个需要被处理器进行特殊处理的处理器定义的异常和中断条件都被赋予了一个标识号，称为向量（vector）。处理器把赋予异常或中断的向量用作**中断描述符表 IDT（Interrupt Descriptor Table）**中的一个索引号，来定位一个异常或中断的处理程序入口点位置。

允许的向量号范围是 0 到 255。其中 0 到 31 保留用作 80X86 处理器定义的异常和中断

范围在 32 到 255 的向量号用于用户定义的中断。这些中断通常用于外部 I/O 设备，使得这些设备可以通过外部硬件中断机制向处理器发送中断。表 4-8 中给出了为 80X86 定义的异常和 NMI 中断分配的向量。

![1727593959053](assets/1727593959053.png)







### 4.6.2中断源和异常源

#### 4.6.2.1 中断源

处理器从两种地方接收中断：

- 外部（硬件产生）的中断；
- 软件产生的中断。

外部中断通过处理器芯片上两个引脚（INTR 和 NMI）接收。当引脚 INTR 接收到外部发生的中断信号时，处理器就会从系统总线上读取外部中段控制器（例如 8259A）提供的中断向量号。当引脚 NMI 接收到信号时，就产生一个非屏蔽中断。它使用固定的中断向量号 2。任何通过处理器 INTR 引脚接收的外部中断都被称为可屏蔽硬件中断，包括中断向量号 0 到 255。标志寄存器 EFLAGS 中的 IF 标志可用来屏蔽所有这些硬件中断。

通过在指令操作数中提供中断向量号，INT n 指令可用于从软件中产生中断。注意，EFLAGS 中的 IF 标志不能够屏蔽使用 INT 指令从软件中产生的中断。





#### 4.6.2.2 异常源

处理器接收的异常也有两个来源：

- 处理器检测到的程序错误异常；
- 软件产生的异常。

在应用程序或操作系统执行期间，如果处理器检测到程序错误，就会产生一个或多个异常。80X86 处理器为其检测到的每个异常定义了一个向量。**异常可以被细分为故障（faults）、陷阱（traps）和中止（aborts）**

指令 INTO、INT 3 和 BOUND 指令可以用来从软件中产生异常。这些指令可对指令流中指定点执行的特殊异常条件进行检查。例如，INT 3 指令会产生一个断点异常。







### 4.6.3异常分类

根据异常被报告的方式以及导致异常的指令是否能够被重新执行，异常可被细分成故障（Fault）、陷阱（Trap）和中止（Abort）。

- **Fault 是一种通常可以被纠正的异常，并且一旦被纠正程序就可以继续运行。**当出现一个 Fault，处理器会把机器状态恢复到产生 Fault 的指令之前的状态。此时异常处理程序的返回地址会指向产生 Fault 的指令，而不是其后面一条指令。因此在返回后产生 Fault 的指令将被重新执行。
- **Trap 是一个引起陷阱的指令被执行后立刻会报告的异常。**Trap 也能够让程序或任务连贯地执行。Trap 处理程序的返回地址指向引起陷阱指令的随后一条指令，因此在返回后会执行下一条指令。
- **Abort 是一种不会总是报告导致异常的指令的精确位置的异常，并且不允许导致异常的程序重新继续执行。**Abort 用于报告严重错误，例如硬件错误以及系统表中存在不一致性或非法值。







### 4.6.4程序或任务的重新执行

为了让程序或任务在一个异常或中断处理完之后能重新恢复执行，除了中止（Abort）之外的所有异常都能报告精确的指令位置，并且所有中断保证是在指令边界上发生。

对于**故障类异常**，处理器产生异常时保存的返回指针指向出错指令。重新执行引发出错的指令通常用于处理访问指令操作数受阻的情况。**Fault 最常见的一个例子是页面故障（Page-fault）异常**。

对于**陷阱 Trap 类异常**，处理器产生异常时保存的返回指针指向引起陷阱操作的后一条指令。如果在一条执行控制转移的指令执行期间检测到一个 Trap，则返回指令指针会反映出控制的转移情况。

**中止 Abort 类异常**不支持可靠地重新执行程序或任务。



**中断**会严格地支持被中断程序的重新执行而不会丢失任何连贯性。







### 4.6.5开启和禁止中断

标志寄存器 EFLAGS 的中断允许标志 IF（Interrupt enable Flag）能够禁止为处理器 INTR 引脚上收到的可屏蔽硬件中断提供服务。当 IF=0 时，处理器禁止发送到 INTR 引脚的中断；当 IF=1 时，则发送到 INTR引脚的中断信号会被处理器进行处理。

IF 标志并不影响发送到 NMI 引脚的非屏蔽中断，也不影响处理器产生的异常。

IF 标志可以使用**指令 STI 和 CLI** 来设置或清除。







### 4.6.6异常和中断的优先级

如果在一条指令边界有多个异常或中断等待处理时，处理器会按规定的次序对它们进行处理。表 4-9给出了异常和中断源类的优先级。处理器会首先处理最高优先级类中的异常或中断。低优先级的异常会被丢弃，而低优先级的中断则会保持等待。

![1727594446952](assets/1727594446952.png)

![1727594456492](assets/1727594456492.png)









### 4.6.7中断描述符表

中断描述符表 IDT（Interrupt Descriptor Table）将每个异常或中断向量分别与它们的处理过程联系起来。IDT 也是由 8 字节长描述符组成的一个数组。为了构成 IDT 表中的一个索引值，处理器把异常或中断的向量号*8。因为最多只有 256 个中断或异常向量，所以 IDT 无需包含多于 256 个描述符。

**IDT 表可以驻留在线性地址空间的任何地方**，处理器使用 **IDTR 寄存器**来定位 IDT 表的位置。这个寄存器中**含有 IDT 表 32 位的基地址和 16 位的长度（限长）值**，见图 4-26 所示。IDT 表基地址应该对齐在 8字节边界上以提高处理器的访问效率。

![1727594548181](assets/1727594548181.png)

指令 LIDT 和 SIDT 指令分别用于加载和保存 IDTR 寄存器的内容。







### 4.6.8IDT 描述符

IDT 表中可以存放三种类型的门描述符：

- 中断门（Interrupt gate）描述符
- 陷阱门（Trap gate）描述符
- 任务门（Task gate）描述

图 4-27 给出了这三种门描述符的格式。中断门和陷阱门含有一个长指针（即段选择符和偏移值），处理器使用这个长指针把程序执行权转移到代码段中异常或中断的处理过程中。任务门描述符中含有一个任务 TSS 段的选择符，该任务用于处理异常和/或中断。

![1727594676832](assets/1727594676832.png)







### 4.6.9异常与中断处理

当响应一个异常或中断时，处理器使用异常或中断的向量作为 IDT 表中的索引。如果索引值指向中断门或陷
阱门，则处理器使用与 CALL 指令操作调用门类似的方法调用异常或中断处理过程。如果索引值指向任务门，则处理器使用与 CALL 指令操作任务门类似的方法进行任务切换，执行异常或中断的处理任务。



异常或中断门引用运行在当前任务上下文中的异常或中断处理过程，见图 4-28 所示。

![1727594732759](assets/1727594732759.png)







图 4-29 转移到中断处理过程时堆栈使用方法

![1727594778560](assets/1727594778560.png)

为了从中断处理过程中返回，处理过程必须使用 IRET 指令。IRET 指令与 RET 指令类似，但 IRET 还会把保存的寄存器内容恢复到 EFLAGS 中。不过只有当 CPL 是 0 时才会恢复 EFLAGS 中的 IOPL 字段，并且只有当 CPL<=IOPL 时，IF 标志才会被改变。 如果当调用中断处理过程时发生了堆栈切换，那么在返回时 IRET 指令会切换回到原来的堆栈。







### 4.6.10 中断处理任务

当通过 IDT 中任务门来访问异常或中断处理过程时就会导致任务切换。使用单独的任务来处理异常或中断有如下好处：

- 被中断程序或任务的完整上下文会被自动保存；
- 在处理异常或中断时，新的 TSS 可以允许处理过程使用新特权级 0 的堆栈。在当前特权级 0 的堆栈已毁坏时如果发生了一个异常或中断，那么在为中断过程提供一个新特权级 0 的堆栈条件下，通过任务门访问中断处理过程能够防止系统崩溃；
- 通过使用单独的 LDT 给中断或异常处理任务独立的地址空间，可以把它与其他任务隔离开来。

使用独立任务处理异常或中断的不足之处是：在任务切换时必须对大量机器状态进行保存，使得它比使用中断门的响应速度要慢，导致中断延时增加。



IDT 中的任务门会引用 GDT 中的 TSS 描述符，图 4-30 所示。切换到句柄任务的过程与普通任务切换过程相同。

![1727594910765](assets/1727594910765.png)







### 4.6.11 错误码

当异常条件与一个特定的段相关时，处理器会把一个错误码压入异常处理过程的堆栈上。出错码的格式见图 4-31 所示。

![1727594989646](assets/1727594989646.png)





页故障（Page-fault）异常的错误码格式与上面的不同，见图 4-32 所示。只有最低 3 个比特位有用，它们的名称与页表项中的最后三位相同（U/S、W/R、P）。含义和作用分别是：

- 位 0（P），异常是由于页面不存在或违反访问特权而引发。
- 位 1（W/R），异常是由于内存读或写操作引起。
- 位 2（U/S），发生异常时 CPU 执行的代码级别。

![1727595039563](assets/1727595039563.png)

另外，处理器还会把引起页面故障异常所访问用的线性地址存放在 CR2 中。页出错异常处理程序可以使用这个地址来定位相关的页目录和页表项。













## 4.7 任务管理

**任务（Task）是处理器可以分配调度、执行和挂起的一个工作单元。**它可用于执行程序、任务或进程、操作系统服务、中断或异常处理过程和内核代码。

80X86 提供了多任务的硬件支持。任务是一个正在运行的程序，或者是一个等待准备运行的程序。通过中断、异常、跳转或调用，我们可以执行一个任务。描述符表中与任务相关的描述符有两类：任务状态段描述符和任务门。当执行权传给这任何一类描述符时，都会造成任务切换。任务切换很象过程调用，但任务切换会保存更多的处理器状态信息。任务切换会把控制权完全转移到一个新的执行环境，即新任务的执行环境。这种转移操作要求保存处理器中几乎所有寄存器的当前内容，包括标志寄存器 EFLAGS 和所有段寄存器。与过程不过，任务不可重入。任务切换不会把任何信息压入堆栈中，处理器的状态信息都被保存在内存中称为**任务状态段（Task state segment）**的数据结构中。





### 4.7.1任务的结构和状态

一个任务由两部分构成：任务执行空间和任务状态段 TSS（Task-state segment）。任务执行空间包括代
码段、堆栈段和一个或多个数据段，见图 4-33 所示。如果操作系统使用了处理器的特权级保护机制，那么
任务执行空间就需要为每个特权级提供一个独立的堆栈空间。TSS 指定了构成任务执行空间的各个段，并
且为任务状态信息提供存储空间。

![1727595195671](assets/1727595195671.png)

一个任务使用指向其 TSS 的段选择符来指定。 当一个任务被加载进处理器中执行时，那么该任务的段选择符、基地址、段限长以及 TSS 段描述符属性就会被加载进**任务寄存器 TR（Task Register）**中。如果使用了分页机制，那么任务使用的页目录表基地址就会被加载进**控制寄存器 CR3** 中。

当前执行任务的状态由处理器所有以下一些内容组成：

- ◼ 所有通用寄存器和段寄存器信息；
- ◼ 标志寄存器 EFLAGS、程序指针 EIP、控制寄存器 CR3、任务寄存器和 LDTR 寄存器；
- ◼ 段寄存器指定的任务当前执行空间；
- ◼ I/O 映射位图基地址和 I/O 位图信息（在 TSS 中）；
- ◼ 特权级 0、1 和 2 的堆栈指针（在 TSS 中）；
- ◼ 链接至前一个任务的链指针（在 TSS 中）。







### 4.7.2任务的执行

软件或处理器可以使用以下方法之一来调度执行一个任务：

- ◼ 使用 CALL 指令明确地调用一个任务；
- ◼ 使用 JMP 指令明确地跳转到一个任务（Linux 内核使用的方式）；
- ◼ （由处理器）隐含地调用一个中断句柄处理任务；
- ◼ 隐含地调用一个异常句柄处理任务；

所有这些调度任务执行的方法都会使用一个指向任务门或任务 TSS 段的选择符来确定一个任务。

当调度一个任务执行时，当前正在运行任务和调度任务之间会自动地发生任务切换操作。在任务切换期间，当前运行任务的执行环境（称为任务的状态或上下文）会被保存到它的 TSS 中并且暂停该任务的执行。此后新调度任务的上下文会被加载进处理器中，并且从加载的 EIP 指向的指令处开始执行新任务。

如果当前执行任务（调用者）调用了被调度的新任务（被调用者），那么调用者的 TSS 段选择符会被保存在被调用者 TSS 中，从而提供了一个返回调用者的链接。对于所有 80X86 处理器，任务是不可递归调用的，即任务不能调用或跳转到自己。

作为任务切换操作的一部份，处理器也会切换到另一个 LDT，从而允许每个任务对基于 LDT 的段具有不同逻辑到物理地址的映射。同时，页目录寄存器 CR3 也会在切换时被重新加载，因此每个任务可以有自己的一套页表。这些保护措施能够用来隔绝各个任务并且防止它们相互干扰。







### 4.7.3任务管理数据结构

处理器定义了以下一些支持多任务的寄存器和数据结构：

- ◼ 任务状态段 TSS；
- ◼ TSS 描述符；
- ◼ 任务寄存器 TR；
- ◼ 任务门描述符；
- ◼ 标志寄存器 EFLAGS 中的 NT 标志。

使用这些数据结构，处理器可以从一个任务切换到另一个任务，同时保存原任务的上下文，以允许任务重新执行。



#### 4.7.3.1 任务状态段

用于恢复一个任务执行的处理器状态信息被保存在称为任务状态段 TSS（Task state segment）的段中。图 4-34 给出了 32 位 CPU 使用的 TSS 的格式。TSS 段中各字段可分成两大类：动态字段和静态字段。

![1727596620831](assets/1727596620831.png)







#### 4.7.3.2 TSS 描述符

与其他段一样，任务状态段 TSS 也是使用段描述符来定义。图 4-35 给出了 TSS 描述符的格式。**TSS描述符只能存放在 GDT 中。**

![1727596653094](assets/1727596653094.png)







#### 4.7.3.3 任务寄存器

**任务寄存器 TR（Task Register）**中存放着 16 位的**段选择符**以及**当前任务 TSS 段的整个描述符（不可见部分）**。这些信息是从 GDT 中当前任务的 TSS 描述符中复制过来的。处理器使用任务寄存器 TR 的不可见部分来缓冲 TSS 段描述符内容。

指令 LTR 和 STR 分别用于加载和保存任务寄存器的可见部分，即 TSS 段的选择符。







#### 4.7.3.4 任务门描述符

任务门描述符（Task gate descriptor）提供对一个任务间接、受保护地的引用，其格式见图所示。任务门描述符可以被存放在 GDT、LDT 或 IDT 表中。

程序可以通过任务门描述符或者 TSS 段描述符来访问一个任务。图 4-36 示出了 LDT、GDT 和 IDT 表中的任务门如何都指向同一个任务。

![1727596794067](assets/1727596794067.png)









### 4.7.4任务切换

处理器可使用一下 4 种方式之一执行任务切换操作：
1. 当前任务对 GDT 中的 TSS 描述符执行 JMP 或 CALL 指令；
2. 当前任务对 GDT 或 LDT 中的任务门描述符执行 JMP 或 CALL 指令；
3. 中断或异常向量指向 IDT 表中的任务门描述符；
4. 当 EFLAGS 中的 NT 标志置位时当前任务执行 IRET 指令。

JMP、CALL 和 IRET 指令以及中断和异常都是处理器的普通机制，可用于不发生任务切换的环境中。对于 TSS 描述符或任务门的引用（当调用或跳转到一个任务），或者 NT 标志的状态（当执行 IRET 指令时）确定了是否会发生任务切换。



为了进行任务切换，JMP 或 CALL 指令能够把控制转移到 TSS 描述符或任务门上。使用这两种方式的作用相同，都会导致处理器把控制转移到指定的任务中，见图 4-37 所示。

![1727596893532](assets/1727596893532.png)









### 4.7.5任务链

TSS 的前一任务连接（Backlink）字段以及 EFLAGS 中的 NT 标志用于返回到前一个任务操作中。NT标志指出了当前执行的任务是否是嵌套在另一个任务中执行，并且当前任务的前一任务连接字段中存放着嵌套层中更高层任务的 TSS 选择符，若有的话（见图 4-38 所示）。

![1727596929118](assets/1727596929118.png)









### 4.7.6任务地址空间

任务的地址空间由任务能够访问的段构成。这些段包括代码段、数据段、堆栈段、TSS 中引用的系统段以及任务代码能够访问的任何其他段。这些段都被映射到处理器的线性地址空间中，并且随后被直接地或者通过分页机制映射到处理器的物理地址空间中。

TSS 中的 LDT 字段可以用于给出每个任务自己的 LDT。**对于一个给定的任务，通过把与任务相关的所有段描述符放入 LDT 中，任务的地址空间就可以与其他任务的隔绝开来。**

当然，几个任务也可以使用同一个 LDT。

因为**所有任务都可以访问 GDT**，所以也同样可以创建通过此表访问的**共享段**。

如果开启了分页机制，则 **TSS 中的 CR3 寄存器字段可以让每个任务有它自己的页表**。



#### 4.7.6.1 把任务映射到线性和物理地址空间

有两种方法可以把任务映射到线性地址空间和物理地址空间：

- 所有任务共享一个线性到物理地址空间的映射。当没有开启分页机制时，就只能使用这个办法。不开启分页时，所有线性地址映射到相同的物理地址上。
- 每个任务有自己的线性地址空间，并映射到物理地址空间。通过让每个任务使用不同的页目录，我们就可以使用这种映射形式。因为每次任务切换都会加载 PDBR（控制寄存器 CR3），所以每个任务可以有不同的页目录。



#### 4.7.6.2 任务逻辑地址空间

为了在任务之间共享数据，可使用下列方法之一来为数据段建立共享的逻辑到物理地址空间的映射：

- 通过使用 GDT 中的段描述符。所有任务必须能够访问 GDT 中的段描述符。
- 通过共享的 LDT。两个或多个任务可以使用相同的 LDT，如果它们 TSS 中 LDT 字段指向同一个 LDT。
- 通过映射到线性地址空间公共地址区域的不同 LDT 中的段描述符。











## 4.8 保护模式编程初始化

### 4.8.1进入保护模式时的初始化操作

保护模式所需要的一些数据结构由处理器内存管理功能确定。处理器支持分段模型，可以使用从单个、统一的地址空间平坦模型到每个任务都具有几个受保护地址空间的高度结构化的多段模型。分页机制能够用来部分在内存、部分在磁盘上的大型数据结构信息。这两种地址转换形式都需要操作系统在内存中为内存管理硬件设置所要求的数据结构。因此在处理器能够被切换到保护模式下运行之前，操作系统加载和初始化软件（bootsect.s、setup.s 和head.s）必须在内存中先设置好保护模式下使用的数据结构的基本信息。

这些数据结构包括以下几种：

- ◼ 保护模式中断描述符表 IDT；
- ◼ 全局描述符表 GDT；
- ◼ 任务状态段 TSS；
- ◼ 局部描述符表 LDT；
- ◼ 若使用分页机制，则起码需要设置一个页目录和一个页表；
- ◼ 处理器切换到保护模式下运行的代码段；
- ◼ 含有中断和异常处理程序的代码模块



在能够切换到保护模式之前，软件初始化代码还必须设置以下系统寄存器：

- ◼ 全局描述符表基地址寄存器 GDTR；
- ◼ 中断描述符表基地址寄存器 IDTR；
- ◼ 控制寄存器 CR1--CR3；



在初始化了这些数据结构、代码模块和系统寄存器之后，通过设置 CR0 寄存器的保护模式标志 PE（位0），处理器就可以切换到保护模式下运行。





#### 4.8.1.1 保护模式系统结构表

软件初始化期间在内存中设置的保护模式系统表主要依赖于操作系统将要支持的内存管理类型：平坦的、平坦并支持分页的、分段的或者分段并支持分页的。

为了实现无分页的平坦内存模型，软件初始化代码必须起码设置具有一个代码段和一个数据段的 GDT表。支持分页机制的平坦内存模型还需要一个页目录和至少一个页表。在可以使用 GDT表之前，必须使用 LGDT 指令把 GDT 表的基地址和长度值加载到 GDTR 寄存器中。

而多段模型则还需要用于操作系统的其他段，以及用于每个应用程序的段和 LDT 表段。LDT 表的段描述符要求存放在 GDT 表中。



#### 4.8.1.2 保护模式异常和中断初始化

软件初始化代码必须设置一个保护模式 IDT，其中最少需要含有处理器可能产生的每个异常向量对应的门描述符。

在可以使用 IDT 之前，必须使用 LIDT 指令把 IDT 表基地址和长度加载到 IDTR 寄存器中。





#### 4.8.1.3 分页机制初始化

分页机制由控制寄存器 CR0 中的 PG 标志设置。当这个标志被清 0 时（即硬件复位时的状态），分页机制被关闭；当设置了 PG 标志，就开启分页机制。在设置 PG 标志之前，必须先初始化以下数据结构和寄存器：

- 软件必须在物理内存中建立至少一个页目录和一个页表。
- 把页目录表的物理基地址加载到 CR3 寄存器中（也称为 PDBR 寄存器）。
- 处理器处于保护模式下。
- 设置PG标志的指令应该立刻跟随一条JMP指令。MOV CR0指令后面的JMP指令会改变执行流，所以它会清空 80X86 处理器已经取得或已译码的指令。
- 设置 PG 标志到跳转指令 JMP 之间的代码必须来自对等映射（即跳转之前的线性地址与开启分页后的物理地址相同）的一个页面上。





#### 4.8.1.4 多任务初始化

如果将要使用多任务机制，并且/或者允许改变特权级，那么软件初始化代码必须至少设置一个 TSS及相应的 TSS 段描述符（因为特权级 0、1 和 2 的各栈段指针需要从 TSS 中取得）。在创建 TSS 描述符时不要将其标注为忙（不要设置忙标志），该标志仅由处理器在执行任务切换时设置。**TSS 的描述符也存放在 GDT 中**

在处理器切换到保护模式之后，可以用 LTR 指令把 TSS 段描述符的选择符加载到任务寄存器 TR 中。

在 LTR 指令执行之后，随后对任务寄存器的操作由任务切换进行。





### 4.8.2模式切换

为了让处理器工作在保护模式下，必须从实地址模式下进行模式切换操作。一旦进入保护模式，软件通常不会再需要回到实地址模式。为了还能运行为实地址模式编制的程序，通常在虚拟-8086 模式中运行比再切换回实模式下运行更为方便。













## 4.9 一个简单的多任务内核实例

### 4.9.1多任务程序结构和工作原理

本节给出的内核实例由 2 个文件构成。

- 一个是使用 as86 语言编制的引导启动程序 `boot.s`，用于在计算机系统加电时从启动盘上把内核代码加载到内存中；
- 另一个是使用 GNU as 汇编语言编制的内核程序 `head.s`，其中实现了两个运行在特权级 3 上的任务在时钟中断控制下相互切换运行，并且还实现了在屏幕上显示字符的一个系统调用。我们把这两个任务分别称为任务 A 和任务 B（或任务 0 和任务 1），它们会调用这个显示系统调用在屏幕上分别显示出字符'A'和'B'，直到每个 10 毫秒切换到另一个任务。





`boot.s` 程序编译出的代码共 512 字节，将被存放在软盘映像文件的第一个扇区中，见图 4-39 所示。PC 机在加电启动时，ROM BIOS 中的程序会把启动盘上第一个扇区加载到物理内存 0x7c00（31KB）位置开始处，并把执行权转移到 0x7c00 处开始运行 boot 程序代码。

![1727597789115](assets/1727597789115.png)

`boot` 程序的主要功能是把软盘或映像文件中的 head 内核代码加载到内存某个指定位置处，并在设置好临时 GDT 表等信息后，把处理器设置成运行在保护模式下，然后跳转到 head 代码处去运行内核代码。

boot 程序代码在内存中移动 head 代码的示意图见图4-40 所示。

![1727597840510](assets/1727597840510.png)









`head.s` 程序运行在 32 位保护模式下，其中主要包括初始设置的代码、时钟中断 int 0x08 的过程代码、系统调用中断 int 0x80 的过程代码以及任务 A 和任务 B 等的代码和数据。其中初始设置工作主要包括：

- ①重新设置 GDT 表；
- ②设置系统定时器芯片；
- ③重新设置 IDT 表并且设置时钟和系统调用中断门；
- ④移动到任务 A 中执行。

在虚拟地址空间中 head.s 程序的内核代码和任务代码分配图如图 4-41 所示。

![1727597918054](assets/1727597918054.png)





在 head 程序编译出的目标文件中以及最终得到的软盘映像文件中，代码和数据的组织形式见图 4-42 所示。

![1727597959383](assets/1727597959383.png)


































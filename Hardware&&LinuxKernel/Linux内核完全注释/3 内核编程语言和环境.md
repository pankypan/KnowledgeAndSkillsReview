# 3 内核编程语言和环境

## 3.1 as86 汇编器

在 Linux 0.1x 系统中使用了两种汇编器（Assembler）。

- 一种是能产生 16 位代码的 **as86 汇编器**，使用配套的 **ld86 链接器**；
- 另一种是 GNU 的**汇编器 gas（as）**，使用 **GNU ld 链接器**来链接产生的目标文件。



由于 Linux系统仅使用 as86 和 ld86 编译和链接上面提到的两个 16 位汇编程序 `bootsect.s 和 setup.s`，因此这里仅介绍这两个程序中用到的一些汇编程序语法和汇编命令（汇编指示符）的作用和用途。







### 3.1.1 as86 汇编语言语法

汇编器专门用来把低级汇编语言程序编译成含机器码的二进制程序或目标文件。汇编器会把输入的一个汇编语言程序（例如 srcfile）编译成目标文件（objfile）。汇编的命令行基本格式是：

```bash
as [选项] -o objfile srcfile
```

其中选项用来控制编译过程以产生指定格式和设置的目标文件。输入的汇编语言程序 srcfile 是一个文本文件。该文件内容必须是由换行字符结尾的一系列文本行组成。

**标号**是由一个标识符后跟一个冒号':'组成。**在编译过程中，当汇编器遇到一个标号，那么当前位置计数器的值就会赋值给这个标号。**因此一条汇编语句通常由标号（可选）、指令助记符（指令名）和操作数三个字段组成，标号位于一条指令的第一个字段。它代表其所在位置的地址，通常指明一个跳转指令的目标位置。最后还可以跟随用注释符开始的注释部分。

汇编器编译产生的目标文件 objfile 通常起码包含三个段或区**3（section）**，即:

- 正文段（.text）
- 数据段（.data）
- 未初始化数据段（.bss）





### 3.1.3 as86 汇编语言程序的编译和链接

现在我们说明如何编译链接示例程序 boot.s 来生成我们需要引导扇区程序 boot。编译和链接上面示例程序需要执行以下前两条命令：

```bash
[/root]# as86 -0 -a -o boot.o boot.s // 编译。生成与 as 部分兼容的目标文件。
[/root]# ld86 -0 -s -o boot boot.o // 链接。去掉符号信息。
[/root]# ls -l boot*
-rwx--x--x 1 root root 544 May 17 00:44 boot
-rw------- 1 root root 249 May 17 00:43 boot.o
-rw------- 1 root root 767 May 16 23:27 boot.s
[/root]# dd bs=32 if=boot of=/dev/fd0 skip=1 // 写入软盘或 Image 盘文件中。
16+0 records in
16+0 records out
[/root]# 
```

- 第 1 条命令利用 as86 汇编器对 boot.s 程序进行编译，生成 boot.o 目标文件。
- 第 2 条命令使用链接器 ld86对目标文件执行链接操作，最后生成 MINIX 结构的可执行文件 boot。其中选项
  - '-0'用于生成 8086 的 16位目标程序；
  - '-a'用于指定生成与 GNU as 和 ld 部分兼容的代码。
  - '-s'选项用于告诉链接器要去除最后生成的可执行文件中的符号信息。
  - '-o' 指定生成的可执行文件名称。







### 3.1.4 as86 和 ld86 使用方法和选项

as86 和 ld86 的使用方法和选项如下：

**as 的使用方法和选项：**

```bash
as [-03agjuw] [-b [bin]] [-lm [list]] [-n name] [-o objfile] [-s sym] srcfile
```





**ld 连接器的使用语法和选项：**

```bash
// 对于生成 Minix a.out 格式的版本：
ld [-03Mims[-]] [-T textaddr] [-llib_extension] [-o outfile] infile...

// 对于生成 GNU-Minix 的 a.out 格式的版本：
ld [-03Mimrs[-]] [-T textaddr] [-llib_extension] [-o outfile] infile...
```











## 3.2 GNU as 汇编

as86 汇编器仅用于编译内核中的 boot/bootsect.s 引导扇区程序和实模式下的设置程序`boot/setup.s`。**内核中其余所有汇编语言程序（包括 C 语言产生的汇编程序）均使用 gas 来编译，并与 C语言程序编译产生的模块链接。**

由于操作系统许多关键代码要求有很高的执行速度和效率，因此在一个操作系统源代码中通常就会包含大约 10%左右的起关键作用的汇编语言程序量。





### 3.2.1编译 as 汇编语言程序

使用 as 汇编器编译一个 as 汇编语言程序的基本命令行格式如下所示：

```bash
as [ 选项 ] [ -o objfile ] [ srcfile.s ...]
```

其中 objfile 是 as 编译输出的目标文件名，srcfile.s 是 as 的输入汇编语言程序名。如果没有使用输出文件名，那么 as 会编译输出名称为 a.out 的默认目标文件。

**一个程序的源程序可以被放置在一个或多个文件中**，程序的源代码是如何分割放置在几个文件中并不会改变程序的语义。**程序的源代码是所有这些文件按次序的组合结果。**每次运行 as 编译器，它只编译一个源程序。但一个源程序可由多个文本文件组成（终端的标准输入也是一个文件）。

as 的输出文件是输入的汇编语言程序编译生成的二进制数据文件，即目标文件。除非我们使用选项'-o'指定输出文件的名称，否则 as 将产生名为 a.out 的输出文件。目标文件主要用于作为链接器 ld 的输入文件。目标文件中包含有已汇编过的程序代码、协助 ld 产生可执行程序的信息、以及可能还包含调试符号信息。

假如我们想单独编译 boot/head.s 汇编程序，那么可以在命令行上键入如下形式的命令：

```bash
[/usr/src/linux/boot]# as -o head.o head.s
[/usr/src/linux/boot]# ls -l head*
-rw-rwxr-x 1 root root 26449 May 19 22:04 head.o
-rw-rwxr-x 1 root root 5938 Nov 18 1991 head.s
[/usr/src/linux/boot]#
```







### 3.2.2as 汇编语法

为了维持与 gcc 输出汇编程序的兼容性，**as 汇编器使用 AT&T 系统 V 的汇编语法（下面简称为 AT&T 语法）。**这种语法与 Intel 汇编程序使用的语法（简称 Intel 语法）很不一样





#### 3.2.2.1 汇编程序预处理

as 汇编器具有对汇编语言程序内置的简单预处理功能。该预处理功能会调整并删除多余的空格字符和制表符；删除所有注释语句并且使用单个空格或一些换行符替换它们；把字符常数转换成对应的数值。但是该预处理功能不会对宏定义进行处理，也没有处理包含文件的功能。





#### 3.2.2.2 符号、语句和常数

**符号（Symbol）是由字符组成的标识符**，组成符号的有效字符取自于大小写字符集、数字和三个字符`'_.$'`。符号不允许用数字字符开始，并且大小写含义不同。

**语句（Statement）**以换行符或者行分割字符（';'）作为结束。若在一行的最后使用反斜杠字符'\'（在换行符前），那么就可以让一条语句使用多行。当 as 读取到反斜杠加换行符时，就会忽略掉这两个字符。

语句由零个或多个标号（Label）开始，后面可以跟随一个确定语句类型的关键符号。标号由符号后面跟随一个冒号（':'）构成。一条语句的通用格式为：

```bash
标号: 汇编命令 注释部分（可选）
或
标号: 指令助记符 操作数 1, 操作数 2 注释部分（可选）
```

常数是一个数字，可分为字符常数和数字常数两类。



字符串必须用双引号括住，并且其中可以使用反斜杠'\'来转义包含特殊字符。常用转义符序列见表 3-1 所示。反斜杠后若是其他字符，那么该反斜杠将不起作用并且 as 汇编器将会发出警告信息。

![1727599178594](assets/1727599178594.png)

![1727599187450](assets/1727599187450.png)







### 3.2.3指令语句、操作数和寻址

**指令（Instructions）**是 CPU 执行的操作，通常指令也称作**操作码（Opcode）**；**操作数（Operand）**是
指令操作的对象；而**地址（Address）**是指定数据在内存中的位置。

**指令语句**是程序运行时刻执行的一条语句，它通常可包含 4 个组成部分：

- ◼ 标号（可选）；
- ◼ 操作码（指令助记符）；
- ◼ 操作数（由具体指令指定）；
- ◼ 注释

一条指令语句可以含有 0 个或最多 3 个用逗号分开的操作数。

操作数可以是立即数（即值是常数值的表达式）、寄存器（值在 CPU 的寄存器中）或内存（值在内存中）。一个间接操作数（Indirect operand）含有实际操作数值的地址值。





#### 3.2.3.1 指令操作码的命名

AT&T 语法中指令操作码名称（即指令助记符）最后一个字符用来指明操作数的宽度。字符'b'、'w'和'l'分别指定 byte、word 和 long 类型的操作数。如果指令名称没有带这样的字符后缀，并且指令语句中不含内存操作数，那么 as 就会根据目的寄存器操作数来尝试确定操作数宽度。

AT&T 语法与 Intel 语法中转换指令的对应关系见表 3-2 所示。

![1727599319069](assets/1727599319069.png)

![1727599327618](assets/1727599327618.png)





#### 3.2.3.2 指令操作码前缀

操作码前缀用于修饰随后的操作码。它们用于重复字符串指令、提供区覆盖、执行总线锁定操作、或指定操作数和地址宽度。例如，串扫描指令'scas'使用前缀执行重复操作：

```assembly
repne scas %es:(%edi), %al
```





#### 3.2.3.3 内存引用

Intel 语法的间接内存引用形式：`section:[base + index*scale + disp]`

对应于如下 AT&T 语法形式：`section:disp(base, index, scale)`

- 其中 base 和 index 是可选的 32 位基寄存器和索引寄存器，disp 是可选的偏移值。
- scale 是比例因子，取值范围是 1、2、4 和 8。scale 其乘上索引 index 用来计算操作数地址。如果没有指定 scale，则 scale 取默认值 1。
- section 为内存操作数指定可选的段寄存器，并且会覆盖操作数使用的当前默认段寄存器。

以下是几个 AT&T 和 Intel 语法形式的内存引用例子：

```assembly
movl var, %eax # 把内存地址 var 处的内容放入寄存器%eax 中。
movl %cs:var, %eax # 把代码段中内存地址 var 处的内容放入%eax 中。
movb $0x0a,%es:(%ebx) # 把字节值 0x0a 保存到 es 段的%ebx 指定的偏移处。
movl $var, %eax # 把 var 的地址放入%eax 中。
movl array(%esi), %eax # 把 array+%esi 确定的内存地址处的内容放入%eax 中。
movl (%ebx, %esi, 4), %eax # 把%ebx+%esi*4 确定的内存地址处的内容放入%eax 中。
movl array(%ebx, %esi, 4), %eax # 把 array + %ebx+%esi*4 确定的内存地址处的内容放入%eax 中。
movl -4(%ebp), %eax # 把 %ebp -4 内存地址处的内容放入%eax 中，使用默认段%ss。
movl foo(,%eax,4), %eax # 把内存地址 foo + eax * 4 处内容放入%eax 中，使用默认段%ds。
```







#### 3.2.3.4 跳转指令

跳转指令用于把执行点转移到程序另一个位置处继续执行下去。这些跳转的目的位置通常使用一个标号来表示。在生成目标代码文件时，汇编器会确定所有带有标号的指令的地址，并且把跳转到的指令的地址编码到跳转指令中。

JMP 是无条件跳转指令，并可分为直接（direct）跳转和间接（indirect）跳转两类，而条件跳转指令只有直接跳转的形式。下面是直接和间接跳转的几个例子。

```assembly
jmp NewLoc # 直接跳转。无条件直接跳转到标号 NewLoc 处继续执行。
jmp *%eax # 间接跳转。寄存器%eax 的值是跳转的目标位置。
jmp *(%eax) # 间接跳转。从%eax 指明的地址处读取跳转的目标位置。
```









### 3.2.4区与重定位

**区（Section）（也称为段、节或部分）用于表示一个地址范围**，操作系统将会以相同的方式对待和处理在该地址范围中的数据信息。**区的概念主要用来表示编译器生成的目标文件（或可执行程序）中不同的信息区域**，例如目标文件中的正文区或数据区。

**链接器 ld** 会把输入的目标文件中的内容按照一定规律**组合生成一个可执行程序**。当 as 汇编器输出一个目标文件时，该目标文件中的代码被默认设置成从地址 0 开始。此后 ld 将会在链接过程中为不同目标文件中的各个部分分配不同的最终地址位置。ld 会把程序中的字节块移动到程序运行时的地址处。这些块是作为固定单元进行移动的。它们的长度以及字节次序都不会被改变。这样的固定单元就被称作是区（或段、部分）。而**为区分配运行时刻的地址的操作就被称为重定位（Relocation）操作**，其中包括调整目标文件中记录的地址，从而让它们对应到恰当的运行时刻地址上。

as 汇编器输出产生的目标文件中至少具有３个区，分别被称为正文（text）、数据（data）和 bss 区。

当一个区被重定位时，为了让链接器 ld 知道哪些数据会发生变化以及如何修改这些数据，as 汇编器也会往目标文件中写入所需要的重定位信息。为了执行重定位操作，在每次涉及目标文件中的一个地址时，ld 必须知道：

- ◼ 目标文件中对一个地址的引用是从什么地方算起的？
- ◼ 该引用的字节长度是多少？
- ◼ 该地址引用的是哪个区？(地址)-(区的开始地址)的值等于多少？
- ◼ 对地址的引用与程序计数器 PC（Program-Counter）相关吗？

实际上，as 使用的所有地址都可表示为：(区)+(区中偏移)。





#### 3.2.4.1 链接器涉及的区

链接器 ld 只涉及如下 4 类区：

- **text 区、data 区** -- 这两个区用于保存程序。as 和 ld 会分别独立而同等地对待它们。当程序在运行时，则通常 text 区是不会改变的。text区通常会被进程共享，其中含有指令代码和常数等内容。程序运行时 data 区的内容通常是会变化的，例如，C 变量一般就存放在 data 区中。
- **bss 区** -- 在程序开始运行时这个区中含有 0 值字节。该区用于存放未初始化的变量或作为公共变量存储空间。
- **absolute 区** -- 该区的地址 0 总是“重定位”到运行时刻地址 0 处。如果你不想让 ld 在重定位操作时改变你所引用的地址，那么就使用这个区。
- **undefined 区** -- 对不在先前所述各个区中对象的地址引用都属于本区。



图 3-2 中是 3 个理想化的可重定位区的例子。这个例子使用传统的区名称：'.text'和'.data'。其中水平轴表示内存地址。

![1727599909928](assets/1727599909928.png)





#### 3.2.4.2 子区

汇编取得的字节数据通常位于 text 或 data 区中。有时候在汇编源程序某个区中可能分布着一些不相邻的数据组，但是你可以会想让它们在汇编后聚集在一起存放。as 汇编器允许你利用子区（subsection）来达到这个目的。





#### 3.2.4.3 bss 区

bss 区用于存储局部公共变量。你可以在 bss 区中分配空间，但是在程序运行之前不能在其中放置数据。因为当程序刚开始执行时，bss 区中所有字节内容都将被清零。









### 3.2.5符号

在程序编译和链接过程中，**符号（Symbol）**是一个比较重要的概念。**程序员使用符号来命名对象，链接器使用符号进行链接操作，而调试器利用符号进行调试。**

**标号（Label）是后面紧随一个冒号的符号**。此时该符号代表活动位置计数器的当前值

**符号名**以一个字母或'._'字符之一开始。





#### 3.2.5.1 特殊点符号

**特殊符号`'.'`表示 as 汇编的当前地址。**因此表达式`mylab: .long .'`就会把 mylab 定义为包含它自己所处的地址值。





#### 3.2.5.2 符号属性

**除了名字以外，每个符号都有“值”和“类型”属性。**根据输出的格式不同，符号也可以具有辅助属性。如果不定义就使用一个符号，as 就会假设其所有属性均为 0。这指示该符号是一个外部定义的符号。









### 3.2.6as 汇编命令

汇编命令是指示汇编器操作方式的伪指令。汇编命令用于要求汇编器为变量分配空间、确定程序开始地址、指定当前汇编的区、修改位置计数器值等。所有汇编命令的名称都以'.'开始，其余是字符，并且大小写无关。但是通常都使用小写字符。







### 3.2.8AS 汇编器命令行选项

- -a 开启程序列表
- -f 快速操作
- -o 指定输出的目标文件名
- -R 组合数据区和代码区
- -W 取消警告信息











## 3.3 C 语言程序

### 3.3.1C 程序编译和链接

使用 **gcc 汇编器**编译 C 语言程序时通常会经过四个处理阶段，即**预处理阶段、编译阶段、汇编阶段和链接阶段**，见图 3-3 所示。

![1727600270022](assets/1727600270022.png)

- 在**前处理阶段中**，gcc 会把 C 程序传递给 C 前处理器 CPP，对 C 语言程序中指示符和宏进行替换处理，输出**纯 C 语言代码**；
- 在**编译阶段**，gcc 把 C 语言程序编译生成对应的与机器相关的 **as 汇编语言代码**；
- 在**汇编阶段**，as 汇编器会把汇编代码转换成**机器指令**，并以**特定二进制格式**输出保存在**目标文件**中；
- 最后 **GNU ld 链接器**把程序的相关目标文件组合链接在一起，生成程序的**可执行映像文件**。

调用 gcc 的命令行格式与编译汇编语言的格式类似：

```bash
gcc [ 选项 ] [ -o outfile ] infile ...
```

其中 infile 是输入的 C 语言文件；outfile 是编译产生的输出文件。对于某次编译过程，并非一定要全部执行这四个阶段，使用命令行选项可以令 gcc 编译过程在某个处理阶段后就停止执行。



gcc使用案例：

```bash
gcc -o hello hello.c // 编译 hello.c 程序，生成执行文件 hello。
gcc -S -o hello.s hello.c // 编译 hello.c 程序，生成对应汇编程序 hello.s。
gcc -c -o hello.o hello.c // 编译 hello.c 程序，生成对应目标文件 hello.o 而不链接。
```



在编译象 Linux 内核这样的包含很多源程序文件的大型程序时，通常使用 make 工具软件对整个程序的编译过程进行自动管理







### 3.3.2嵌入汇编

具有输入和输出参数的嵌入汇编语句的基本格式为：

```assembly
asm(“汇编语句”
 : 输出寄存器
 : 输入寄存器
 : 会被修改的寄存器);
```

- 除第 1 行以外，后面带冒号的行若不使用就都可以省略。其中，“asm”是内联汇编语句关键词；
- **“汇编语句”**是你写汇编指令的地方；
- **“输出寄存器”**表示当这段嵌入汇编执行完之后，哪些寄存器用于存放输出数据。此地，这些寄存器会分别对应一 C 语言表达式值或一个内存地址；
- **“输入寄存器”**表示在开始执行汇编代码时，这里指定的一些寄存器中应存放的输入值，它们也分别对应着一 C 变量或常数值。
- **“会被修改的寄存器”**表示你已对其中列出的寄存器中的值进行了改动，gcc 编译器不能再依赖于它原先对这些寄存器加载的值。









### 3.3.3圆括号中的组合语句

花括号对 ”{...}” 用于把变量声明和语句组合成一个复合语句（组合语句）或一个语句块，这样在语义上这些语句就等同于一条语句。组合语句的右花括号后面不需要使用分号。圆括号中的组合语句，即形如”({...})”的语句，可以在 GNU C 中用作一个表达式使用。语句表达式具有如下示例的形式：

```c
({ int y = foo(); int z;
 if (y > 0) z = y;
 else z = -y;
 3 + z; })
```







### 3.3.4寄存器变量

GNU 对 C 语言的另一个扩充是允许我们把一些变量值放到 CPU 寄存器中，即所谓寄存器变量。这样CPU 就不用经常花费较长时间访问内存去取值。寄存器变量可以分为 2 种：全局寄存器变量和局部寄存器变量。全局寄存器变量会在程序的整个运行过程中保留寄存器专门用于几个全局变量。相反，局部寄存器变量不会保留指定的寄存器，而仅在内嵌 asm 汇编语句中作为输入或输出操作数时使用专门的寄存器。

在 GNU C 程序中我们可以在函数中用如下形式定义一个局部寄存器变量：

```c
register int res __asm__("ax");
```

这里 ax 是变量 res 所希望使用的寄存器。定义这样一个寄存器变量并不会专门保留这个寄存器不派其他用途。







### 3.3.5内联函数

在程序中，通过把一个函数声明为内联（inline）函数，就可以让 gcc 把函数的代码集成到调用该函数的代码中去。这样处理可以去掉函数调用时进入/退出时间开销，从而肯定能够加快执行速度。因此把一个函数声明为内联函数的主要目的就是能够尽量快速的执行函数体。

把一个函数声明为内联函数的方法是在函数声明中使用关键词”inline”，例如内核文件 fs/inode.c 中的如下函数：

```c
inline int inc(int *a)
{
    (*a)++;
}
```











## 3.4 C 与汇编程序的相互调用

### 3.4.1 C 函数调用机制

在 Linux 内核程序 `boot/head.s` 执行完基本初始化操作之后，就会跳转去执行`init/main.c` 程序。

**函数调用操作**包括从一块代码到另一块代码之间的**双向数据传递和执行控制转移**。数据传递通过函数参数和返回值来进行。另外，我们还需要在进入函数时为函数的局部变量分配存储空间，并且在退出函数时收回这部分空间。Intel 80x86 CPU 为**控制传递提供了简单的指令**，而**数据的传递和局部变量存储空间的分配与回收**则**通过栈操作**来实现。





#### 3.4.1.1 栈帧结构和控制转移权方式

大多数 CPU 上的程序实现使用栈来支持函数调用操作。栈被用来传递函数参数、存储返回信息、临时保存寄存器原有值以备恢复以及用来存储局部数据。**单个函数调用操作所使用的栈部分被称为栈帧（Stack frame）结构**，其通常结构见图 3-4 所示。

**栈帧结构**的两端由两个指针来指定。

- 寄存器 ebp 通常用作帧指针（frame pointer），
-  esp 则用作栈指针（stack pointer）。

在函数执行过程中，栈指针 esp 会随着数据的入栈和出栈而移动，因此函数中对大部分数据的访问都基于帧指针ebp 进行。

![1727603310200](assets/1727603310200.png)

指令 CALL 和 RET 用于处理函数调用和返回操作。

- **调用指令 CALL** 的作用是把返回地址压入栈中并且跳转到被调用函数开始处执行。返回地址是程序中紧随调用指令 CALL 后面一条指令的地址。
- **返回指令 RET** 用于弹出栈顶处的地址并跳转到该地址处。在使用该指令之前，应该先正确处理栈中内容，使得当前栈指针所指位置内容正是先前CALL指令保存的返回地址。另外，若返回值是一个整数或一个指针，那么寄存器 eax 将被默认用来传递返回值。



尽管某一时刻只有一个函数在执行，但我们还是需要确定在一个函数（调用者）调用其他函数（被调用者）时，被调用者不会修改或覆盖掉调用者今后要用到的寄存器内容。因此 **Intel CPU 采用了所有函数必须遵守的寄存器用法统一惯例。该惯例指明，**

- **寄存器 eax、edx 和 ecx 的内容必须由调用者A自己负责保存。**
- 另外，**寄存器 ebx、esi 和 edi 的内容则必须由被调用者 B 来保护**。

当被调用者需要使用这些寄存器中的任意一个时，必须首先在栈中保存其内容，并在退出时恢复这些寄存器的内容。因为调用者 A（或者一些更高层的函数）并不负责保存这些寄存器内容，但可能在以后的操作中还需要用到原先的值。还有寄存器 ebp 和 esp 也必须遵守第二个惯例用法。





#### 3.4.1.2 函数调用举例

作为一个例子，我们来观察下面 C 程序 exch.c 中函数调用的处理过程。

```c
void swap(int * a, int *b)
{
    int c;
    c = *a;
    *a = *b;
    *b = c;
}

int main()
{
    int a, b;
    a = 16; b = 32;
    swap(&a, &b);
    return (a - b);
}
```

这两个函数的栈帧结构见图 3-5 所示。

![1727603595876](assets/1727603595876.png)

使用命令`gcc -Wall -S -oexch.s exch.c`可以生成该 C 语言程序的汇编程序 `exch.s `代码







#### 3.4.1.3 main()也是一个函数

C 程序的**主程序 main()**也是一个函数。这是因为在**编译链接时它将会作为 `crt0.s` 汇编程序的函数被调用**。`crt0.s` 是一个桩（stub）程序，名称中的“crt”是“C run-time”的缩写。**该程序的目标文件将被链接在每个用户执行程序的开始部分，主要用于设置一些初始化全局变量等**。Linux 0.12 中 crt0.s 汇编程序见如下所示。其中建立并初始化全局变量_environ 供程序中其它模块使用。

```assembly
.text
.globl _environ # 声明全局变量 _environ（对应 C 程序中的 environ 变量）。

__entry: # 代码入口标号。
movl 8(%esp), %eax # 取程序的环境变量指针 envp 并保存在_environ 中。
movl %eax, _environ # envp 是 execve()函数在加载执行文件时设置的。
call _main # 调用我们的主程序。其返回状态值在 eax 寄存器中。
pushl %eax # 压入返回值作为 exit()函数的参数并调用该函数。
1: call _exit
jmp 1b # 控制应该不会到达这里。若到达这里则继续执行 exit()。
.data
_environ: # 定义变量_environ，为其分配一个长字空间。
.long 0
```









### 3.4.2在汇编程序中调用 C 函数

在汇编程序调用一个 C 函数时，程序需要首先按照逆向顺序把函数参数压入栈中，即函数最后（最右边的）一个参数先入栈，而最左边的第 1 个参数在最后调用指令之前入栈，见图 3-6 所示。然后执行 **CALL指令去执行被调用的函数**。在调用函数返回后，程序需要再把先前压入栈中的函数参数清除掉。

![1727603979081](assets/1727603979081.png)

在执行 CALL 指令时，CPU 会把 CALL 指令下一条指令的地址压入栈中（见图中 EIP）。如果调用还涉及到代码特权级变化，那么 CPU 还会进行堆栈切换，并且把当前堆栈指针、段描述符和调用参数压入新堆栈中。由于 Linux 内核中只使用中断门和陷阱门方式处理特权级变化时的调用情况，并没有使用 CALL指令来处理特权级变化的情况，因此这里对特权级变化时的 CALL 指令使用方式不再进行说明。



另外，我们说**汇编程序调用 C 函数比较自由**的另一个原因是我们可以根本不用 CALL 指令而采用 JMP指令来同样达到调用函数的目的。方法是在参数入栈后人工把下一条要执行的指令地址压入栈中，然后直接使用 JMP 指令跳转到被调用函数开始地址处去执行函数。此后当函数执行完成时就会执行 RET 指令把我们人工压入栈中的下一条指令地址弹出，作为函数返回的地址。







### 3.4.3在 C 程序中调用汇编函数

从 C 程序中调用汇编程序函数的方法与汇编程序中调用 C 函数的原理相同，但 Linux 内核程序中不常使用。调用方法的着重点仍然是对函数参数在栈中位置的确定上。当然，如果调用的汇编语言程序比较短，那么可以直接在 C 程序中使用上面介绍的内联汇编语句来实现。下面我们以一个示例来说明编制这类程序的方法。包含两个函数的汇编程序 `callee.s` 见如下所示。

调用这两个函数的 C 程序 caller.c 见如下所示。



这两个文件的编译和运行结果见如下所示：

```bash
[/usr/root]# as -o callee.o callee.s
[/usr/root]# gcc -o caller caller.c callee.o
[/usr/root]# ./caller
Calculating...
The result is 15
[/usr/root]#
```













## 3.5 Linux 0.12 目标文件格式

为了生成内核代码文件，Linux 0.12 使用了两种编译器。

- 第一种是**汇编编译器 as86 和相应的链接程序（或称为链接器）ld86**。它们专门用于编译和链接运行在实地址模式下的 16 位内核引导扇区程序bootsect.s 和设置程序 setup.s。
- 第二种是 **GNU 的汇编器 as（gas）和 C 语言编译器 gcc 以及相应的链接程序 gld**。

**编译器**用于为源程序文件产生对应的**二进制代码和数据目标文件**。**链接程序**用于对相关的所有目标文件进行组合处理，**形成一个可被内核加载执行的目标文件**，即**可执行文件**。

为便于描述，这里把**编译器**生成的目标文件称为**目标模块文件（简称模块文件）**，而把**链接程序**输出产生的可执行目标文件称为**可执行文件**。并且**把它们都统称为目标文件**。







### 3.5.1目标文件格式

在 Linux 0.12 系统中，GNU gcc 或 gas 编译输出的目标模块文件和链接程序所生成的**可执行文件**都使用了 **UNIX 传统的 a.out 格式**。这是一种被称为**汇编与链接输出（Assembly & linker editor output）的目标文件格式**。对于具有内存分页机制的系统来说，这是一种简单有效的目标文件格式。见图 3-7 所示。其中代码区和数据区通常也被分别称为正文段（代码段）和数据段。

![1727604363712](assets/1727604363712.png)

a.out 格式 7 个区的基本定义和用途是：

- **执行头部分（exec header）**。执行文件头部分。该部分中含有一些参数（exec 结构），是有关目标文件的整体结构信息。
- **代码区（text segment）**。由编译器或汇编器生成的二进制指令代码和数据信息，含有程序执行时被加载到内存中的指令代码和相关数据。可以以只读形式被加载。
- **数据区（data segment）**。由编译器或汇编器生成的二进制指令代码和数据信息，这部分含有已经初始化过的数据，总是被加载到可读写的内存中。
- **代码重定位部分（text relocations）**。这部分含有供链接程序使用的记录数据。在组合目标模块文件时用于定位代码段中的指针或地址。
- **符号表部分（symbol table）**。这部分同样含有供链接程序使用的记录数据。这些记录数据保存着模块文件中定义的全局符号以及需要从其他模块文件中输入的符号，或者是由链接器定义的符号，用于在模块文件之间对命名的变量和函数（符号）进行交叉引用。
- **字符串表部分（string table）**。该部分含有与符号名相对应的字符串。用于调试程序调试目标代码，与链接过程无关。这些信息可包含源程序代码和行号、局部符号以及数据结构描述信息等。



#### 3.5.1.1 执行头部分

目标文件的文件头中含有一个长度为 32 字节的 exec 数据结构，通常称为文件头结构或执行头结构。其定义如下所示。

```c
struct exec {
 unsigned long a_magic // 执行文件魔数。使用 N_MAGIC 等宏访问。
 unsigned a_text // 代码长度，字节数。
 unsigned a_data // 数据长度，字节数。
 unsigned a_bss // 文件中的未初始化数据区长度，字节数。
 unsigned a_syms // 文件中的符号表长度，字节数。
 unsigned a_entry // 执行开始地址。
 unsigned a_trsize // 代码重定位信息长度，字节数。
unsigned a_drsize // 数据重定位信息长度，字节数。
}
```





#### 3.5.1.2 重定位信息部分

Linux 0.12 系统的模块文件和执行文件都是 a.out 格式的目标文件，但是只有编译器生成的模块文件中包含用于链接程序的重定位信息。**代码段和数据段的重定位信息均有重定位记录（项）构成**，每个记录的长度为 8 字节，其结构如下所示。

```c
struct relocation_info
{
 int r_address; // 段内需要重定位的地址。
 unsigned int r_symbolnum:24; // 含义与 r_extern 有关。指定符号表中一个符号或者一个段。
 unsigned int r_pcrel:1; // 1 比特。PC 相关标志。
 unsigned int r_length:2; // 2 比特。指定要被重定位字段长度（2 的次方）。
 unsigned int r_extern:1; // 外部标志位。1 - 以符号的值重定位。0 - 以段的地址重定位
 unsigned int r_pad:4; // 没有使用的 4 个比特位，但最好将它们复位掉。
};
```

重定位项的功能有两个。

- 一是当代码段被重定位到一个不同的基地址处时，重定位项则用于指出需要修改的地方。
- 二是在模块文件中存在对未定义符号引用时，当此未定义符号最终被定义时链接程序就可以使用相应重定位项对符号的值进行修正。





#### 3.5.1.3 符号表和字符串部分

目标文件的最后部分是符号表和相关的字符串表。符号表记录项的结构如下所示。

```c
struct nlist {
 union {
 char *n_name; // 字符串指针，
 struct nlist *n_next; // 或者是指向另一个符号项结构的指针，
 long n_strx; // 或者是符号名称在字符串表中的字节偏移值。
 } n_un;
 unsigned char n_type; // 该字节分成 3 个字段，参见 a.out.h 文件 146-154 行。
 char n_other; // 通常不用。
 short n_desc; // 
 unsigned long n_value; // 符号的值。
};
```









### 3.5.2Linux 0.12 中的目标文件格式

在 Linux 0.12 系统中，我们可以使用 `objdump` 命令来查看模块文件或执行文件中文件头结构的具体值。

例如，下面列出了 hello.o 目标文件及其执行文件中文件头的具体值。

```bash
[/usr/root]# gcc -c -o hello.o hello.c
[/usr/root]# gcc -o hello hello.o
[/usr/root]# 
[/usr/root]# hexdump -x hello.o
0000000 0107 0000 0028 0000 0000 0000 0000 0000
0000010 0024 0000 0000 0000 0010 0000 0000 0000
0000020 6548 6c6c 2c6f 7720 726f 646c 0a21 0000
0000030 8955 68e5 0000 0000 e3e8 ffff 31ff ebc0
0000040 0003 0000 c3c9 0000 0019 0000 0002 0d00
0000050 0014 0000 0004 0400 0004 0000 0004 0000
0000060 0000 0000 0012 0000 0005 0000 0010 0000
0000070 0018 0000 0001 0000 0000 0000 0020 0000
0000080 6367 5f63 6f63 706d 6c69 6465 002e 6d5f
0000090 6961 006e 705f 6972 746e 0066
000009c
[/usr/root]# objdump -h hello.o
```





磁盘上 **`a.out` 执行文件**的各区在进程逻辑地址空间中的对应关系见图 3-8 所示。

![1727609413912](assets/1727609413912.png)









### 3.5.3链接程序输出

**链接程序**对输入的**一个或多个模块文件**以及**相关的库函数模块**进行处理，最终生成相应的**二进制执行文件**或者是**一个所有模块组合而成的大模块文件**。在这个过程中，链接程序的首要任务是给执行文件（或者输出的模块文件）进行存储空间分配操作。一旦存储位置确定，链接程序就可以继续执行符号邦定操作和代码修正操作。

每个模块文件中包括几种类型的段，链接程序的第二个任务就是把所有模块中相同类型的段组合连接在一起，在输出文件中为指定段类型形成单一一个段。

例如，对于具有两个输入模块文件和需要连接一个库函数模块的情况，其存储分配情况见图 3-9 所示。

![1727609539102](assets/1727609539102.png)

此后链接程序就可以为所有段分配地址。在每个段内，链接程序会把输入模块文件中的同类型段顺序存放，并按字进行边界对齐。



**当 Linux 0.12 内核加载一个可执行文件时**，它会根据文件头部结构中的信息首先判断文件是否是一个合适的可执行文件，即其魔数类型是否为 ZMAGIC，然后系统在用户态堆栈顶部为程序设置环境参数和命令行上输入的参数信息块并为其构建一个任务数据结构。接着在设置了一些相关寄存器值后利用堆栈返回技术去执行程序。**执行程序映像文件中的代码和数据将会在实际执行到或用到时利用需求加载技术（Load on demand）动态加载到内存中。**

对于 Linux 0.12 内核的编译过程，它是根据内核的配置文件 Makefile 使用 make 命令指挥编译器和链接程序操作而完成的。







### 3.5.4 链接程序预定义变量

在链接过程中，**链接器** ld 和 ld86 会**使用变量记录下执行程序中每个段的逻辑地址**。因此在程序中可以通过访问这几个外部变量来获得程序中段的位置。链接器预定义的外部变量通常至少有 `etext、_etext、edata、_edata、end 和_end`。









### 3.5.5 System.map 文件

当运行 GNU 链接器 gld（ld）时若使用了'-M'选项，或者使用 nm 命令，则会在标准输出设备（通常是屏幕）上打印出链接映像（link map）信息，即是指由连接程序产生的目标程序内存地址映像信息。其中列出了程序段装入到内存中的位置信息。具体来讲有如下信息：

- 目标文件及符号信息映射到内存中的位置；
- 公共符号如何放置；
- 链接中包含的所有文件成员及其引用的符号。

通常我们会把发送到标准输出设备的**链接映像信息重定向到一个文件中（例如 System.map）**。在编译内核时，`linux/Makefile` 文件产生的 `System.map` 文件就用于存放内核符号表信息。符号表是所有内核符号及其对应地址的一个列表，当然也包括上面说明的_etext、_edata 和_end 等符号的地址信息。随着每次内核的编译，就会产生一个新的对应 System.map 文件。当内核运行出错时，通过 System.map 文件中的符号表解析，就可以查到一个地址值对应的变量名，或反之。

利用 System.map 符号表文件，在内核或相关程序出错时，就可以获得我们比较容易识别的信息。符号表的样例如下所示：

```bash
c03441a0 B dmi_broken
c03441a4 B is_sony_vaio_laptop
c03441c0 b dmi_ident
c0344200 b pci_bios_present
c0344204 b pirq_table
```

其中每行说明一个符号，第 1 栏指明符号值（地址）；第 2 栏是符号类型，指明符号位于目标文件的哪个区（sections）或其属性；第 3 栏是对应的符号名称。



尽管内核本身实际上不使用 System.map，但其他程序，象 klogd、lsof、ps 以及其他象 dosemu 等许多软件都需要有一个正确的 System.map 文件。利用该文件，这些程序就可以根据已知的内存地址查找出对应的内核变量名称，便于对内核的调试工作。











## 3.6 Make 程序和 Makefile 文件

Make 程序, 其主要功能是能够自动地确定在一个包含很多源文件的大型程序中哪些文件需要被重新编译，并对这些文件发出重新编译的命令。

为了使用 make 工具程序，我们需要先编写一个名称为 Makefile（或 makefile）的文本文件供 make 执行时使用。Makefile 文件中主要包含一些 make 要遵守的执行规则和要求执行的命令等内容，用于告诉 make需要对所涉及的源文件做哪些操作和处理以生成相应的目标文件。





### 3.6.1 Makefile 文件内容

一个 Makefile 文件可以包括五种元素：显式规则、隐含规则、变量定义、指示符和注释信息。

- **显式规则（explicit rules）**用于指定何时以及怎样重新编译一个或多个被称作规则的目标（rule’s targets）的文件。
- **隐含规则（implicit rules）**则是根据目标和对象的名称来确定何时和如何重新编译一个或多个被称作规则的目标的文件。
- **变量定义（variable definitions）**用于在一行上为一个变量定义一个文本字符串。
- **指示符（directives）**是 make 的一个命令，用于指示其在读取 Makefile 文件时执行的特定操作。
- **注释（comments）**是指 Makefile 文件中以’#’字符开始的文字部分。

一旦编写好一个适当的 Makefile 文件，那么每次修改源程序后我们就可以在 shell 命令行上简单地键入“make”来执行所有必要的程序更新操作。make 会根据 Makefile 中的内容以及文件的最后更新时间来确定哪些文件需要被更新（重新编译）。对于每个需要被更新的文件，make 会执行 Makefile 文件中记录的相关命令。









### 3.6.2 Makefile 文件中的规则

简单的 Makefile 文件中含有一些如下形式的规则。这些规则主要用来描述操作对象（源文件和目标文件）之间的依赖关系。

```
target（目标）…：prerequisites（先决条件）…
                command（命令）
                …
                …
```

其中，

- **target（目标）**对象通常是指程序生成的一个文件的名称，例如它可以是一个可执行文件或者是一个以“.o”结尾的目标文件（Object File）。目标也可以是所要采取活动的名称，例如“清理”（“clean”）。
- **prerequisite（先决条件或称依赖对象）**是用以创建 target 所必要或者依赖的一系列文件或其他目标。
  target 通常依赖于多个这样的必要文件或目标文件。
- **command（命令）**是指 make 所执行的操作，通常就是一些 shell 命令，是生成 target 需要执行的操作。







### 3.6.3Makefile 文件示例

省略。。。





### 3.6.4 make 处理 Makefile 文件的方式

默认情况下，make 会从 Makefile 文件中第一个目标开始执行（不包括以’.’开始的目标）。**该首个目标被称为 Makefile 的默认最终目标（default goal）**。最终目标就是 make 努力尝试更新的目标。

对于 Makefile 中其他的一些规则，若其目标（文件）出现在最终目标的先决条件中，则也会被处理。若最终目标（或任何目标）并不依赖于某些其他规则，则 make 并不会处理这些规则，除非我们主动要求make 去处理。例如当运行 make 时，我们可以在命令行上给出 Makefile 中某个特定规则的目标名称，以执行该目标指定的更新操作，例如使用命令 make clean。

总体来说，Make 程序会使用 Makefile 文件内容来判断哪些.o 目标文件需要被更新，然后确定其中哪些目标确实需要被更新。如果.o 目标文件要比其所有相关文件都要新，则说明该.o 目标文件已经是最新的而无需再作更新处理。当然，作为第一个最终目标的输入条件（先决条件）中的所有必需目标都会先期执行更新处理。





### 3.6.5 Makefile 中的变量

省略。。。





### 3.6.6 让 make 自动推断命令

省略。。。







### 3.6.7 隐含规则中的自动变量

省略。。。












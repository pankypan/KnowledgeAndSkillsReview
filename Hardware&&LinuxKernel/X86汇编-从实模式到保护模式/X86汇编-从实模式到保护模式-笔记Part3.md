# X86汇编-从实模式到保护模式-笔记Part3

## 第15章 任务切换

在一个多任务的环境中，可以同时存在多个任务，每个任务都有各自的局部描述符表（LDT）和任务状态段（TSS）。在局部描述符表中存放着专属于任务局部空间的段的描述符。

所谓多任务系统，是指能够同时执行两个以上任务的系统。即使前一个任务没有执行完，下一个任务也可以开始执行。但是，**什么时候切换到另一个任务，以及切换到哪一个任务执行，主要是操作系统的责任，处理器只负责具体的切换过程，包括保护前一个任务的现场。**

有两种基本的任务切换方式，一种是协同式的，从一个任务切换到另一个任务，需要当前任务主动地请求暂时放弃执行权，或者在通过调用门请求操作系统服务时，由操作系统“趁机”将控制转移到另一个任务。这种方式依赖于每个任务的“自律”性，当一个任务失控时，其他任务可能得不到执行的机会。

另一种是抢占式的，在这种方式下，可以安装一个定时器中断，并在中断服务程序中实施任务切换。硬件中断信号总会定时出现，不管处理器当时在做什么，中断都会适时地发生，而任务切换也就能够顺利进行。在这种情况下，每个任务都能获得平等的执行机会。而且，即使一个任务失控，也不会导致其他任务没有机会执行。







### 任务切换前的设置

如图15-1 所示，所有任务共享一个全局空间，这是内核或者操作系统提供的，包含了系统服务程序和数据；同
时，每个任务还有自己的局部空间，每个任务的功能都不一样，所以，局部空间包含的是一个任务区别于其他任务的私有代码和数据。

![1725679677117](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725679677117.png)

在一个任务内，全局空间和局部空间具有不同的特权级别。使用门，可以在任务内将控制从3特权级的局部空间转移到0 特权级的全局空间，以使用内核或者操作系统提供的服务。

**任务切换**是以任务为单位的，是指离开一个任务，转到另一个任务中去执行。**任务转移**相对来说要复杂得多，当一个任务正在执行时，处理器的各个部分都和该任务息息相关：

- 段寄存器指向该任务所使用的内存段；
- 通用寄存器保存着该任务的中间结果，等等。

离开当前任务，转到另一个任务开始执行时，要保存旧任务的各种状态，并恢复新任务的运行环境。





我们通过一个虚假的调用门返回，使处理器回到任务的局部空间执行，当前特权级别降为3。事实上，这是没有必要的，这样做很别扭。

- 首先，处理器在刚进入保护模式时，是以0 特权级别运行的，而且执行的一般是操作系统代码，也必须是0 特权级别的，这样才能方便地控制整个计算机。
- 其次，任务并不一定非得是3 特权级别的，也可以是0 特权级别的。
- 特别是，操作系统除了为每一个任务提供服务外，也会有一个作为任务而独立存在的部分，而且是0 特权级别的任务，以完成一些管理和控制功能，比如提供一个界面和用户进行交互。

既然是这样，**当计算机加电之后，一旦进入保护模式，就直接创建和执行操作系统的0 特权级任务**，这既自然，也很方便。然后，可以从该任务切换到其他任务，不管它们是哪个特权级别的。

既然如此，我们在这一章里就要**首先创建0 特权级别的操作系统（内核）任务**。

本章同样没有主引导程序，还要使用第13 章的主引导程序，内核部分有一些改动，增加了和任务切换有关的代码。





现在来看代码清单15-1。

内核的入口点在第848 行，第906 行之前的工作都和上一章相同，主要是显示处理器品牌信息，以及安装供每个任务使用的调用门。

接下来的工作是**创建0 特权级的内核任务**，并将当前正在执行的内核代码段划归该任务。当前代码的作用是创建其他任务，管理它们，所以称做**任务管理器**，或者叫程序管理器。

**任务状态段（TSS）是一个任务存在的标志**，没有它，就无法执行任务切换，因为任务切换时需要保存旧任务的各种状态数据。**为了追踪程序管理器的TSS，需要保存它的基地址和选择子**，保存的位置是内核数据段。

接着，第914～918 行**对TSS 进行最基本的设置**。程序管理器任务没有自己的LDT，任务可以没有自己的LDT，这是允许的。**程序管理器可以将自己所使用的段描述符安装在GDT 中**。另外，程序管理器任务是运行在0 特权级别上的，不需要创建额外的栈。

第923～928 行，在GDT 中创建TSS 的描述符。**必须创建TSS 的描述符，而且只能安装在GDT 中**。

为了**表明当前正在任务中执行**，所要做的最后一个工作是**将当前任务的TSS 选择子传送到任务寄存器TR** 中。第932 行正是用来完成这个工作的。执行这条指令后，处理器用该**选择子**访问GDT，找到相对应的**TSS 描述符，将其B 位置“1”**，表示该任务正在执行中（或者处于挂起状态）。同时，还要将该**描述符**传送到**TR 寄存器的描述符高速缓存器**中。







### 任务切换的方法

**第一种任务切换的方法是借助于中断**，这也是现代抢占式多任务的基础。原因很简单，只要中断没有被屏蔽，它就能随时发生。特别是定时器中断，能够以准确的时间间隔发生，可以用来强制实施任务切换。

在保护模式下，中断向量表不再使用，取而代之的，是**中断描述符表**。它和GDT、LDT 是一样的，用于保存描述符。唯一不同的地方是，它保存的是门描述符，包括中断门、陷阱门和任务门。当中断发生时，处理器用中断号乘以8（因为每个描述符占8 字节），作为索引访问**中断描述符表**，取出门描述符。**门描述符**中有中断处理过程的**代码段选择子**和**段内偏移量**，这和调用门是一样的。接着，转移到相应的位置去执行。

一般的中断处理可以使用中断门和陷阱门。**中断门和陷阱门**允许在任务内实施中断处理，转到全局空间去执行一些系统级的管理工作，本质上，也是任务内的**控制转移**行为。

但是，在中断发生时，如果该**中断号**对应的门是**任务门**，那么，性质就截然不同了，必须进行**任务切换**。即，**要中断当前任务的执行，保护当前任务的现场，并转换到另一个任务去执行**。

如图15-2 所示，这是**任务门（Task-Gate）描述符**的格式。从图中可见，相对于其他各种描述符，任务门描述符中的多数区域没有使用，所以显得特别简单。

**任务门描述符**中的主要成份是**任务的TSS 选择子**。**任务门用于在中断发生时执行任务切换，而执行任务切换时必须找到新任务的任务状态段（TSS）。**所以，任务门应当指向任务的TSS。为了指向任务的TSS，只需要在任务门描述符中给出任务的TSS 选择子就可以了

![1725690622535](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725690622535.png)

这样，当中断发生时，处理器用中断号乘以8 作为索引访问**中断描述符表**。当它发现这是一个**任务门（描述符）**时，就知道应当发起**任务切换**。

- 于是，它取出任务门描述符；再从任务门描述符中取出新任务的TSS 选择子；
- 接着，再用TSS 选择子访问GDT，取出新任务的TSS 描述符。在转到新任务执行前，处理器要先把当前任务的状态保存起来。当前任务的TSS 是由任务寄存器TR 的当前内容指向的，所以，处理器把每个寄存器的“快照”保存到由TR 指向的TSS 中。
- 然后，处理器访问新任务的TSS，从中恢复各个寄存器的内容，包括通用寄存器、标志寄存器EFLAGS、段寄存器、指令指针寄存器EIP、栈指针寄存器ESP，以及局部描述符表寄存器（LDTR）等。
- 最终，任务寄存器TR 指向新任务的TSS，而处理器旋即开始执行新的任务。一旦新任务开始执行，处理器
  固件会自动将其TSS 描述符的B 位置“1”，表示该任务的状态为忙。

当中断发生时，可以执行常规的中断处理过程，也可以进行任务切换。尽管性质不同，但它们都要使用iret 指令返回。前者是返回到同一任务内的不同代码段；后者是返回到被中断的那个任务。问题是，处理器如何区分这两种截然不同的返回类型呢？

如图15-3 所示，32 位处理器的**EFLAGS** 有**NT 位**（位14），意思是**嵌套任务标志（Nested Task Flag）**。**每个任务的TSS 中都有一个任务链接域**（指向前一个任务的指针，参见上一章TSS的结构），可以填写为前一个任务的TSS 描述符选择子。如果当前任务EFLAGS 寄存器的NT位是“1”，则表示当前正在执行的任务嵌套于其他任务内，并且能够通过TSS 任务链接域的指针返回到前一个任务。

![1725692065933](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725692065933.png)

因中断而引发任务切换时，取决于当前任务（旧任务）是否嵌套于其他任务内，其EFLAGS寄存器的NT 位可能是“0”，也可能是“1”。不过这无关紧要，因为处理器不会改变它，而是和其他寄存器一道，写入TSS 中保护起来。另外，当前任务（旧任务）肯定处于“忙”的状态，其TSS 描述符的B 位一定是“1”，在任务切换后同样保持不变。

对新任务的处理是，要把老任务的TSS 选择子填写到新任务TSS 中的任务链接域，同时，将新任务EFLAGS 寄存器的NT 位置“1”，以允许返回（转换）到前一个任务（老任务）继续执行。同时，还要把新任务TSS 描述符的B 位置“1”（忙）。

可以**使用iret 指令从当前任务返回（转换）到前一个任务**，前提是当前任务EFLAGS 寄存器的NT 位必须是“1”。无论任何时候**处理器碰到iret指令，它都要检查NT 位**，

- 如果此位是0，表明是一般的中断过程，按一般的中断返回处理，即，中断返回是任务内的（中断处理过程虽然属于操作系统，但属于任务的全局空间）；
- 如果此位是1，则表明当前任务之所以能够正在执行，是因为中断了别的任务。因此，应当返回原先被中
  断的任务继续执行。此时，由处理器固件把当前任务EFLAGS 寄存器的NT 位改成“0”，并把TSS 描述符的B 位改成“0”（非忙）。在保存了当前任务的状态之后，接着，用新任务（被中断的任务）的TSS 恢复现场。







**第二种任务切换的方法用远过程调用指令CALL，或者远跳转指令JMP 直接发起任务切换。**在这两种情况下，CALL 和JMP 指令的操作数是任务的TSS 描述符选择子或任务门。

```assembly
call 0x0010:0x00000000
jmp 0x0010:0x00000000
```

当处理器执行这两条指令时，首先用指令中给出的描述符选择子访问GDT，分析它的描述符类型。

- 如果是一般的代码段描述符，就按普通的段间转移规则执行；
- 如果是调用门，按调用门的规则执行；
- 如果是TSS 描述符，或者任务门，则执行任务切换。
  - 此时，指令中给出的32 位偏移量被忽略，原因是执行任务切换时，所有处理器的状态都可以从TSS 中获得。
  - 注意，任务门描述符可以安装在中断描述符表中，也可以安装在全局描述符表（GDT）或者局部描述符表（LDT）中。

如果是用于发起任务切换，call 指令和jmp 指令也有不同之处。

- **使用call 指令发起的任务切换类似于因中断发起的任务切换。**
  - 这就是说，由call 指令发起的任务切换是嵌套的，当前任务（旧任务）TSS 描述符的B位保持原的“1”不变，EFLAGS 寄存器的NT 位也不发生变化；
  - 新任务TSS 描述符的B 位置“1”，EFLAGS 寄存器的NT 位也置“1”，表示此任务嵌套于其他任务中。
  - 同时，TSS 任务链接域的内容改为旧任务的TSS 描述符选择子。
- **使用jmp 指令发起的任务切换，不会形成任务之间的嵌套关系。**
  - 执行任务切换时，当前任务（旧任务）TSS 描述符的B 位清零，变为非忙状态，EFLAGS 寄存器的NT 位不变；
  - 新任务TSS 描述符的B 位置“1”，进入忙的状态，EFLAGS 寄存器的NT 位保持从TSS 中加载时的状态不变。





任务切换案例说明：如图15-4 所示，假设任务1 是整个系统中的第一个任务。

![1725692771599](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725692771599.png)

- 当任务1开始执行时，其TSS 描述符的B 位是“1”，EFLAGS 寄存器的NT 位是“0”，不嵌套于其他任务。
- 当从任务1 转换到任务2 后，任务1 仍然为“忙”，EFLAGS 寄存器的NT 位不变（在其TSS中）；
  - 任务2 也变为“忙”，EFLAGS 寄存器的NT位变为“1”，表示嵌套于任务1 中。
  - 同时，任务1 的TSS 描述符选择子也被复制到任务2 的TSS 中（任务链接域）。
- 最后是从任务2 转换到任务3 执行。
  - 和从前一样，任务2 保持“忙”的状态，EFLAGS 寄存器的NT 不变（在其TSS 中）；
  - 任务3 成为当前任务，其TSS 描述符的B 位变成“1”（忙），EFLAGS 寄存器的NT 位也变成“1”，同时，其TSS 的任务链接域指向任务2。





**任务不可重入：**

任务不可重入的本质是，**执行任务切换时，新任务的状态不能为忙**。这里有两个典型的情形：

- 第一种情形，执行任务切换时，新任务不能是当前任务自己。
- 第二种情形，如图15-4 所示，不允许使用CALL 指令从任务3 切换到任务2 和任务1 上。如果不禁止这种情况的话，任务之间的嵌套关系将会因为TSS 任务链接域的破坏而错乱。

**处理器是通过TSS 描述符的B 位来检测重入的。**因中断、iret、call和jmp 指令发起任务切换时，处理器固件会检测新任务TSS 描述符的B位，如果为“1”，则不允许执行这样的切换。









### 用call/jmp/iret 指令发起任务切换的实例







### 处理器在实施任务切换时的操作











## 第16章 分页机制和动态页面分配

在32 位保护模式下，对段的访问本着“先登记，后访问”的原则进行。登记就是在GDT 或LDT 中登记段的描述符，规定了段的地址和边界，以及访问权限；访问时，则需要拿着一个**段描述符的选择子**才行，这就是传说中的“虎符”。**处理器用段界限和特权级别来审查对段的访问，任何非法的造访行为都会被处理器阻止，并立即拉响警报，也就是所谓的异常中断。**

**段是由操作系统负责管理的**。操作系统加载应用程序，根据程序的要求，为它创建一个或多个段，然后把控制权交给它。

但是，**因为段的长度不定，在分配内存时，可能会发生内存中的空闲区域小于要加载的段，或者空闲区域远远大于要加载的段**。在前一种情况下，需要另外寻找合适的空闲区域；在后一种情况下，分配会成功，但太过于浪费。为了解决这个问题，从80386 处理器开始，引入了**分页机制**。

**分页功能**从总体上说，是用**长度固定的页**来代替长度不一定的段，**藉此解决因段长度不同而带来的内存空间管理问题**。尽管操作系统也可以用软件来实施固定长度的内存分配，但太过于复杂，由处理器固件来做这件事，可以使速度和效率最大化。







### 分页机制概述

#### 简单的分页模型

如图16-1 所示，在处理器中有负责分段管理的**段部件**。每个程序或任务都有自己的段，这些段都用段描述符定义。随着程序的执行，当要访问内存时，就用段地址加上偏移量，段部件就会输出一个线性地址。在单纯的分段模式下，线性地址就是物理地址。

![1725694426612](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725694426612.png)







一旦决定采用页式内存管理，就应当把4GB 内存分成大小相同的页。如图16-2 所示，**页的最小单位是4KB，也就是4096 字节，用十六进制数表示就是0x1000**。很显然，页的物理地址，其低12 位始终为全零。

![1725694512290](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725694512290.png)





段管理机制对于Intel 处理器来说是最基本的，任何时候都无法关闭。也就是说，即使启用页管理功能，分段机制依然是起作用的，段部件也依然工作。

分页机制也没有增加程序员的负担，程序依然是按段来组织的。**问题在于，如何将较大的段，映射到大小相同的页面上呢**？

如图16-3 所示，**内存的分配涉及段空间的分配和页分配**。请仔细看这幅图，左边是虚幻的，或者说虚拟的4GB 内存空间，称为**虚拟内存**；右边呢，是实实在在的内存，被分成1048576 个 4KB 页面。

![1725694606680](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725694606680.png)

在**分页模式**下，操作系统可以创建一个为所有任务共用的4GB 虚拟内存空间，**也可以为每一个任务创建独立的4GB 虚拟内存空间**，这都是可行的。当一个程序加载时，操作系统既在要左边的**虚拟内存中分配段空间**，又要在右边的**物理内存中分配相应的页面**。

- 因此，第一个步骤是寻找空闲的段空间，该段空间既没有被其他程序使用，也没有被同一程序内的其他段使用。比如图16-3 所示，假设已经成功找到并分配了一个段空间，基地址为0x00200000，长度为8200 字节。
- **页的最小尺寸是4KB**，也就是4096 字节。因此，8200 字节的段，需要占用3 个页面，其中最后一个页面只用了8 个字节，其余都浪费着，但这无关紧要，如果允许页共享，多个段或多个程序可以用同一个页来存放各自的数据。

**在分段之后，操作系统的任务是把段拆开，并分别映射到物理页。**注意，段必须是连续的，但不要求所分配的页都是连续的、挨在一起的。事实上，在开机之后，会运行不同的程序，这都要分配页。然后，有些程序关闭了，页面要回收。几个回合下来，空闲的页零零散散地分布在物理内存中，一般不会是连续的。

**4GB 虚拟内存空间**不可能用来保存任何数据，因为它是虚拟的，它**只是用来指示内存的使用情况**。当操作系统加载一个程序并创建为任务时，操作系统在虚拟内存空间寻找空闲的段，并映射到空闲的页。然后，到真正开始加载程序时，再把原本属于段的数据按页的尺寸拆开，分开写入对应的页中。





从段部件输出的是**线性地址**，或者叫**虚拟地址**。为了根据线性地址找到页的**物理地址**，**操作系统必须维护一张表，把线性地址转换成物理地址**

作为一个具体的例子，操作系统为程序分配了一个段，段是在虚拟内存中分配的，起始地址为`0x00200000`。该段有8200 字节，需要分配3个页面。

如图16-4 所示，因为有1048576 个页，所以转换表也有1048576项。**这是个一维表格，每个表项占4 字节，内容为页的物理地址**。这个**表格的用法**是这样的：因为页的尺寸是4KB，故，**线性地址的低12 位可用于访问页内偏移，高20 位可用于指定一个物理页**。因此，把线性地址的高20 位当成索引，乘以4，作为表内偏移量，从表中取出一个双字，那就是该线性地址所对应的页的物理地址。

![1725695269909](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725695269909.png)

如图16-4 所示，如果执行指令

```assembly
mov edx,[0x2002]
```

那么，段部件用段地址0x00200000 加上指令中给出的偏移量0x2002，得到线性地址0x00202002。线性地址的高20 位是表格索引，即0x00202。将索引乘以4，得到0x00808，这就是表内偏移。看图，从该单元可以取出一个双字0x00007000，这就是页物理地址。

线性地址的低12 位是页内偏移量，用页物理地址加上页内偏移量，就 是 最 终 的 物 理 内 存 地 址 。 0x00007000 加 上 0x002 ， 得 到0x00007002，这就是实际要访问的物理内存地址。

问题在于，为什么在表内偏移量为0x00808 的地方，会恰好是页地址0x00007000，而不是其他页地址呢？问得好。**当程序加载时，操作系统会首先在虚拟内存中分配段。然后，根据段需要分成多少页，来搜索空闲页面。**

- 当段较大时，要按页的尺寸分成好几个地址区段，操作系统用每个区段的首地址，取高20 位，乘以4，作为偏移量访问表格，并将分配给该区段的页的物理地址写入该表项。
- 最后，把原本需要写入每个区段的程序数据，写到对应的页中。

注意了，在页式内存管理中，页面的管理和分配是独立的，和分段以及段地址没有关系。**操作系统所要做的，就是寻找空闲页面，把它分配给需要的段，并将页的物理地址填写到映射表内。**







基于以上特点，同时为了充分挖掘分页内存管理的潜力，一般来说，**每个任务都可以拥有4GB 的虚拟内存空间**；同时，**每个任务都有自己的页映射表**，如图16-5 所示。

![1725695927768](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725695927768.png)

- 尽管有很多任务，而且每个任务都有自己的4GB 虚拟内存空间，但是，很重要的是，**在整个系统中，物理页面是统一调配的。**
- 另一个会被质疑的问题是，每个任务都有4GB 虚拟内存空间，而物理内存只有一个，最大也才4GB，根本不够分的。事实上，的确不够分配。但是，**操作系统可以将暂时不用的页退避到磁盘，调入马上就要使用的页，通过这种手段来实现分页内存管理。**









#### 页目录、页表和页

为了完成从虚拟地址（线性地址）到物理地址的转换，操作系统应当为每个任务准备一张页映射表。因为任务的虚拟地址空间为4GB，可以分出1048576 个页，所以，映射表需要1048576 个表项，用于存放页的物理地址。又因为每个表项占4 字节，所以，映射表的总大小为4MB。

这张表从一开始就必须完全定义，而且不可避免地要占用4MB 内存空间。为了解决这个问题，同时又不会浪费宝贵的内存空间，**处理器设计了层次化的分页结构**。

**分页结构层次化**的主要手段是不采用单一的映射表，取而代之的是**页目录表和页表**。如图16-6所示，首先，因为4GB 的虚拟内存空间对应着1048576 个4KB 的页，可以随机地抽取这些页，将它们组织在1024 个页表内，**每个页表可以容纳1024 个页。页表内的每个项目叫做页表项，占4 字节，存放的是页的物理地址**，故每个页表的大小是4KB，正好是一个标准页的长度。

注意，页在页表内的分布是随机的，哪个页位于哪个页表中，这是没有规律的。在一个真实的系统中，老任务不断被关闭，新任务不断被创建并投入运行，页面的回收和再分配没有什么规律可言。

如图16-6 所示，在将1048576 个页归拢到1024 个页表之后，接着，再用一个表来指向1024个页表，这就是**页目录表（Page DirectoryTable，PDT）**，和页表一样，**页目录项的长度为4 字节，填写的是页表的物理地址**，共指向1024 个表页，所以页目录表的大小是4KB，正好是一个标准页的长度。

![1725696680263](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725696680263.png)







这样的层次化分页结构是每个任务都拥有的，或者说，**每个任务都有自己的页目录和页表。**。如图16-7 所示，在处理器内部，有一个**控制寄存器CR3**，存放着**当前任务页目录的物理地址**，故又叫做页目录基址寄存器（Page Directory Base Register，PDBR）。

**每个任务都有自己的任务状态段（TSS），它是任务的标志性结构，存放了和任务相关的各种数据，其中就包括了CR3 寄存器域，存放了任务自己的页目录物理地址。**当任务切换时，处理器切换到新任务开始执行，而CR3 寄存器的内容也被更新，以指向新任务的页目录位置。相应地，页目录又指向一个个的页表，这就使得**每个任务都只在自己的地址空间内运行**

从图16-7 中还可以看出，页目录和页表也是普通的页，混迹于全部的物理页中。它们和普通页的不同之处仅仅在于功能不一样。当任务撤销之后，它们和任务所占用的普通页一样会被回收，并分配给其他任务。

![1725696996859](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725696996859.png)









#### 地址变换的具体过程

**对于Intel 处理器来说，有关分页，最简单和最基本的机制就是这些：**

- CR3 寄存器给出了页目录的物理基地址；
- 页目录给出了所有页表的物理地址，而每个页表给出了它所包含的页的物理地址。





**在分页机制下，线性地址转换成物理地址的例子：**

假如某个任务加载后，操作系统根据它的实际情况，在其4GB 虚拟地址空间里创建了一个段，段的起始地址为`0x00800000`，段界限值为`0x5000`，字节粒度。当该任务执行时，段寄存器DS 指向该段。又假设执行了下面一条指令：

```assembly
mov edx,[0x1050]
```

此时，段部件会输出线性地址`0x00801050`。在没有开启分页机制时，这就是要访问的物理内存地址，但现在开启了**分页机制**，所以，这是一个**虚拟地址**，要经过**页部件**的转换，才能得到**物理地址**。

如图16-8 所示，**处理器的页部件专门负责线性地址到物理地址的转换工作**。它首先将段部件送来的32 位线性地址截成3 段，分别是高10位、中间的10 位和低12 位。高10 位是页目录的索引，中间10 位是页表的索引，低12 位则作为页内偏移来用。

![1725697411640](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725697411640.png)

当前任务页目录的物理地址在处理器的CR3 寄存器中，假设它的内容为`0x00005000`。段管理部件输出的线性地址是`0x00801050`，其二进制的形式为`0000 0000 1000 0000 0001 0000 0101 0000`。

1. 高10 位为`0000000010`，也就是十六进制的`0x002`，它是页目录表内的索引，处理器将它乘以4（因为每个目录项为4 字节），作为偏移量访问页目录。最终，处理器从物理地址`0x00005008` 处取得**页表的物理地址`0x08001000`。**
2. 线性地址的中间10 位为二进制的`0000000001`，即`0x001`，处理器要用它作为页表内的索引来取得页的物理地址。处理器将该索引值乘以4，作为偏移量访问页表。最终，处理器又从物理地址`0x08001004 `处取得页的物理地址，这就是我们一直努力寻找的那个页。
3. 页的物理地址是`0x0000C000`，而线性地址的低12 位是数据所在的页内偏移量。故处理器将它们相加，得到物理地址`0x0000C050`，这就是线性地址`0x00801050` 所对应的物理地址，要访问的数据就在这里。



注意，这种变换不是无缘无故的，而是事先安排好的。当任务加载时，操作系统先创建虚拟的段，并根据段地址的高20 位决定它要用到哪些页目录项和页表项。然后，寻找空闲的页，将原本应该写入段中的数据写到一个或者多个页中，并将页的物理地址填写到相应的页表项中。只有这样做了，当程序运行的时候，才能以相反的顺序进行地址变换，并找到正确的数据。









### 使内核在分页机制下工作











### 创建内核任务











### 用户任务的创建和切换















## 第17章 中断和异常的处理与抢占式多任务

### 中断和异常

#### 中断和异常概述

中断和异常的作用是指示系统中的某个地方发生了一些事件，需要引起处理器（包括正在执行中的程序和任务）的注意。当中断和异常发生时，典型的结果是迫使处理器将控制从当前正在执行的程序或任务转移到另一个例程或者任务中去。该例程叫做中断处理程序，或者异常处理程序。如果是一个任务，则发生任务切换。





**中断（Interrupt）：**

- 硬件中断是由外围硬件设备发出的中断信号引发的，以请求处理器提供服务。
  - 当I/O 接口发出中断请求时，会被像8259A 和I/O APIC 这样的中断控制器收集，并发送到处理器。硬件中断完全是随机产生的，与处理器的执行并不同步。
  - 当中断发生时，处理器要先执行完当前的指令，然后才对中断进行处理。
- 软中断是由`int n` 指令引发的中断处理，`n` 是中断号或者叫类型码。





**异常（Exception）**

异常就是我们在介绍16 位汇编语言时所说的内部中断。它们是**处理器内部产生的中断，表示在指令执行的过程中遇到了错误的状况**。当处理器执行一条非法指令，或者因条件不具备，指令不能正常执行时，将引发这种类型的中断。

异常分为三种:

- 第一种是**程序错误异常**，指处理器在执行指令的过程中，检测到了程序中的错误，并由此而引发的异常。
- 第二种是**软件引发的异常**。这类异常通常由into、int3 和bound 指令主动发起。
- 第三种是**机器检查异常**。这种异常是处理器型号相关的，也就是说，每种处理器都不太一样。无论如何，处理器提供了一种对硬件芯片内部和总线处理进行检查的机制，当检测到有错误时，将引发此类异常。

根据**异常情况的性质和严重性**，异常又分为以下三种，并分别实施不同的处理。

- **故障（Faults）。故障通常是可以纠正的**，比如，当处理器执行一个访问内存的指令时，发现那个段或者页不在内存中（P＝0），此时，可以在异常处理程序中予以纠正（分配内存，或者执行磁盘的换入换出操作），返回时，程序可以重新启动并不失连续性。为了做到这一点，**当故障发生时，处理器把机器状态恢复到引起故障的那条指令之前的状态**，在进入异常处理程序时，压入栈中的返回地址（CS 和EIP 的内容）是指向引起故障的那条指令的，而不像通常那样指向下一条指令。如此一来，**当中断返回时，将重新执行引起故障的那条指令，而且不再出错（如果引起异常的情况已经妥善处置）**。这意味着，异常并不总是意味着坏消息，相反，很多时候，它是有益的，就像益虫。如果没有异常，虚拟内存管理将无从谈起。
- **陷阱（Traps）。陷阱中断通常在执行了截获陷阱条件的指令之后立即产生，如果陷阱条件成立的话。**陷阱通常用于调试目的，比如单步中断指令int3 和溢出检测指令into。陷阱中断允许程序或者任务在从中断处理过程返回之后继续进行而不失连续性。因此，当此异常发生时，在转入异常处理程序之前，处理器在栈中压入陷阱截获指令的下一条指令的地址。
- **终止（Aborts）。终止标志着最严重的错误，诸如硬件错误、系统表（GDT、LDT 等）中的数据不一致或者无效。**这类异常总是无法精确地报告引起错误的指令的位置，在这种错误发生时，程序或者任务都不可能重新启动。





表17-1 列出了Intel 处理器在保护模式下的中断和异常。

![1725865818923](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725865818923.png)







#### 中断描述符表、中断门和陷阱门

在**实模式**下，位于内存最低端的1KB 内存，是**中断向量表（IVT）**，定义了256 种中断的入口地址，包括16 位段地址和16 位段内偏移量。当中断发生时，处理器要么自发产生一个中断向量，要么从int n 指令中得到中断向量，或者从外部的中断控制器接受一个中断向量。然后，它将该向量作为索引访问中断向量表。具体的做法是，将中断向量乘以4，作为表内偏移量访问中断向量表，从中取得中断处理过程的段地址和偏移地址，并转到那里执行。



在**保护模式**下，使用**中断描述符表（InterruptDescriptor Table，IDT）**。顾名思义，在这个表里，保存的是**和中断处理过程有关的描述符**，包括中断门、陷阱门和任务门。

中断门和陷阱门的格式如图17-1 所示。

![1725866043654](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725866043654.png)

**调用门、任务门、中断门和陷阱门的描述符**非常相似，从大的方面来说，因为**都用于实施控制转移**，故都包括16 位的目标代码段选择子，以及32 位的段内偏移量。中断门和陷阱门描述符只允许存放在IDT 内，任务门可以位于GDT、LDT 和IDT 中。

**保护模式下的IDT** 不要求必须位于内存的最低端。事实上，在处理器内部，有一个48 位的**中断描述符表寄存器（Interrupt Descriptor Table Register，IDTR）**，保存着中断描述符表在内存中的线性基地址和界限。如图17-2 所示，和GDT 一样，因为整个系统中只需要一个IDT 就够了

![1725866184733](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725866184733.png)

**中断描述符表IDT** 可以位于内存中的任何地方，只要**IDTR 指向了它**，整个中断系统就可以正常工作。为了利用高速缓存使处理器的工作性能最大化，**建议IDT 的基地址是8字节对齐的**（地址的数值能够被8 整除）。

处理器复位时，IDTR 的基地址部分为0，界限部分的值为0xFFFF。





**保护模式下的中断处理过程:**

如图17-3 所示，在保护模式下，当中断和异常发生时，处理器用中断向量乘以8 的结果去访问IDT，从中取得对应的描述符。因为IDT 在内存中的位置是由IDTR 指示的，所以这很容易做到。

![1725866373054](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725866373054.png)

注意:

- 从图17-3 中可以看出，这里没有考虑分页，也没有考虑门描述符是任务门的情况，因为任务门的处理比较特殊。
- 当处理器用中断向量访问IDT 时，要访问的位置超出了IDT 的界限，则产生常规保护异常（#GP）。







#### 中断和异常处理程序的保护

处理器要对中断和异常处理程序进行特权级保护。当目标代码段描述符的特权级（可以用门描述符中的段选择子，从GDT 或LDT 中找到）低于当前特权级CPL 时，即，在数值上，

```assembly
CPL<=目标代码段的DPL
```

时，不允许将控制转移到中断或异常处理程序，违反此规则将引发常规保护异常（#GP）。



不过，中断和异常处理程序的特权级保护也有一些特别之外。具体表现在：

- 因为中断和异常的向量中没有RPL 字段，故当处理器进入中断或异常处理程序，或者通过任务门发起任务切换时，不检查RPL。

- 中断门、陷阱门也有自己的描述符特权级DPL，即门的DPL，参见图17-1。但是，通常情况下不针对该DPL 进行检查，除了用软中断int n和单步中断int3，以及into 引发的中断和异常。在这种情况下，当前特权级CPL 必须高于，或者和门的特权级DPL 相同，即，在数值上，

  ```assembly
  CPL<=目标门描述符的DPL
  ```



当中断和异常发生时，任务可能正在特权级别为0 的全局空间（内核）中执行，也可能正在特权级别为3 的局部空间内执行。因此，当处理器将控制转移到中断或异常处理程序时，如果处理程序运行在较高的特权级别上（数值上较低的），那么，将**转换栈**：

- 根据处理程序的特权级别，从当前任务的TSS 中取得栈段选择子和栈指针。处理器把旧栈的选择子和栈指针压入新栈。毕竟，中断处理程序也是当前任务的一部分。
- 处理器把EFLAGS、CS 和EIP 的当前状态压入新栈。
- 对于有错误代码的异常，处理器还要把错误代码压入新栈，紧挨着EIP 之后，如图17-4（a）所示。
- 处理器把EFLAGS、CS 和EIP 的当前状态压入当前栈。
- 对于有错误代码的异常，处理器还要把错误代码压入当前栈，紧挨
  着EIP 之后，如图17-4（b）所示。

![1725868093909](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725868093909.png)









#### 中断任务

当中断和异常发生时，如果根据中断向量从IDT 中找到的**描述符是任务门**，则不是进行一般的中断处理过程，而是发起**任务切换**。

如图17-5 所示，这是通过中断发起任务切换的原理。

![1725870074273](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725870074273.png)

**用中断发起任务切换**，直觉上的好处是方便。比如，因为**硬件中断的发生是客观的，很容易用它来实现一个剥夺式的、抢占式的多任务系统（硬件调度机制）。**

具体地说，在**中断机制中使用任务门**可以获得以下好处：

- 被中断的那个程序或任务的整个执行环境可以被完整地保存起来（保存到它的TSS 中）。
- 由于接管控制的是一个新的任务，因此，可以使用一个全新的0 特权级栈。这可以有效地防止因当前任务的0 特权级栈遭到破坏而使系统崩溃。
- 由于是切换到一个新任务，因此，它有一个独立的地址空间。







#### 错误代码

有些异常产生时，处理器会在异常处理程序或中断任务的栈中压入一个错误代码。通常，这意味着异常和特定的段选择子或中断向量有关。

如图17-6 所示，压入栈中的错误代码是32 位的，但高16 位不用。

![1725870225089](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725870225089.png)

- EXT 位的意思是，异常是由外部事件引发的（External Event）。此位置位时，表示异常是由NMI、硬件中断等引发的。
- IDT 位用于指示描述符的位置（Descriptor Location）。为“1”时，表示段选择子的索引部分（错误代码的位15～3）是指向中断描述符表（IDT）的；为“0”时，表示段选择子的索引部分指向GDT 或者LDT。
- TI 位仅在IDT 位是“0”的情况下才有意义。此位是“0”时，表示段选择子的索引部分指向GDT，否则，指向LDT。









### 内核的加载和初始化











### 内核任务的创建









### 用户任务的创建
# X86汇编-从实模式到保护模式-笔记Part2

## 第11章 进入保护模式

一般来说，操作系统负责整个计算机软、硬件的管理，它做任何事情都是可以的。但是，**用户程序却应当有所限制，只允许它访问属于自己的数据，即使是转移，也只允许在自己的各个代码段之间进行。**

问题在于，在实模式下，用户程序对内存的访问非常自由，没有任何限制，随随便便就可以修改任何一个内存单元。

在多用户、多任务时代，内存中会有多个用户（应用）程序在同时运行。为了使它们彼此隔离，防止因某个程序的编写错误或者崩溃而影响到操作系统和其他用户程序，使用**保护模式**是非常有必要的。







### 全局描述符表

在保护模式下，对内存的访问仍然使用段地址和偏移地址，**但是，在每个段能够访问之前，必须先进行登记。**

和一个段有关的信息需要8 个字节来描述，所以称为**段描述符（Segment Descriptor）**，每个段都需要一个描述符。为了存放这些描述符，需要在内存中开辟出一段空间。在这段空间里，所有的描述符都是挨在一起，集中存放的，这就构成一个**描述符表**。

**全局描述符表（Global Descriptor Table，GDT）**，所谓全局，意味着该表是为整个软硬件系统服务的。**在进入保护模式前，必须要定义全局描述符表。**



如图11-1 所示，为了跟踪全局描述符表，处理器内部有一个48 位的寄存器，称为**全局描述符表寄存器(GDTR)**。该寄存器分为两部分，分别是32 位的线性地址和16 位的边界。

![1724660777933](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724660777933.png)





理论上，全局描述符表可以位于内存中的任何地方。但是，如图11-2 所示，由于在进入保护模式之后，处理器立即要按新的内存访问模式工作，所以，必须在进入保护模式之前定义GDT。但是，由于在实模式下只能访问1MB 的内存，故GDT 通常都定义在1MB 以下的内存范围中。当然，允许在进入保护模式之后换个位置重新定义GDT。

![1724660882114](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724660882114.png)









### 存储器的段描述符

如图11-3 所示，在实模式下，主引导程序的加载位置是0x0000:0x7c00，也就是物理地址0x07c00。因为现在的地址是32 位的，所以它现在对应着物理地址0x00007c00。主引导扇区程序共512（0x200）字节，所以，我们决定把GDT 设在主引导程序之后，也就是物理地址0x00007e00 处。因为GDT 最大可以为64KB，所以，理论上，它的尺寸可以扩展到物理地址0x00017dff 处。

![1724723657651](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724723657651.png)





在保护模式下，你不能说访问哪个段就访问哪个段，在访问之前，必须先在GDT 内定义要访问的内存段。

**描述符**不是由用户程序自己建立的，而是在加载时，由操作系统根据你的程序结构而建立的，而用户程
序通常是无法建立和修改GDT 的，也就只能老老实实地在自己的地盘上工作。

如图11-4 所示，每个描述符在GDT 中占8 字节。

![1724723788717](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724723788717.png)

段基地址可以是0～4GB 范围内的任意地址，不过，还是建议应当选取那些16 字节对齐的地址。尽管对于Intel 处理器来说，允许不对齐的地址，但是，对齐能够使程序在访问代码和数据时的性能最大化。

- G 位是粒度（Granularity）位，用于解释段界限的含义。当G 位是“0”时，段界限以字节为单位。相反，如果该位是“1”，那么，段界限是以4KB 为单位的。
- S 位用于指定描述符的类型（Descriptor Type）。当该位是“0”时，表示是一个系统段；为“1”时，表示是一个代码段或者数据段
- DPL 表示描述符的特权级（Descriptor Privilege Level，DPL）。这两位用于指定段的特权级。共有4 种处理器支持的特权级别，分别是0、1、2、3，其中0 是最高特权级别，3 是最低特权级别。
  - 不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令（特权指令）只能由0 特权级的程序来执行，为的就是安全。
  - 描述符的特权级用于指定要访问该段所必须具有的最低特权级。如果这里的数值是2，那么，只有特权级别为0、1 和2 的程序才能访问该段，而特权级为3 的程序访问该段时，处理器会予以阻止。
- P 是段存在位（Segment Present）。P 位用于指示描述符所对应的段是否存在。
  - 一般来说，描述符所指示的段都位于内存中。但是，当内存空间紧张时，有可能只是建立了描述符，对应的内存空间并不存在，这时，就应当把描述符的P 位清零，表示段并不存在。另外，同样是在内存空间紧张的情况下，会把很少用到的段换出到硬盘中，腾出空间给当前急需内存的程序使用（当前正在执行的），这时，同样要把段描述符的P 位清零。当再次轮到它执行时，再装入内存，然后将P位置1。
  - P 位是由处理器负责检查的。每当通过描述符访问内存中的段时，如果P 位是“0”，处理器就会产生一个异常中断。通常，该中断处理过程是由操作系统提供的，该处理过程的任务是负责将该段从硬盘换回内存，并将P 位置1。
- D/B 位是“默认的操作数大小”（Default Operation Size）或者“默认的栈指针大小”（Default Stack Pointer Size），又或者“上部边界”（Upper Bound）标志。
- L 位是64 位代码段标志（64-bit Code Segment），保留此位给64位处理器使用。
- TYPE 字段共4 位，用于指示描述符的子类型，或者说是类别。
- AVL 是软件可以使用的位（Available），通常由操作系统来用，处理器并不使用它。









### 安装存储器的段描述符并加载GDTR

第24、25 行，接着安装代码段描述符，该描述符的低32 位是0x7c0001ff，高32 位是0x00409800。结合图11-4 可以分析出，该段的基本情况为：

![1724724640754](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724724640754.png)





第28、29 行，用于安装一个数据段的描述符。对照图11-4，很明显，这个段具有以下性质：

![1724724685740](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724724685740.png)





第32、33 行，用于安装栈段的描述符。对照图11-4，该段的性质如下：

![1724724740816](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724724740816.png)









### 关于第21 条地址线A20 的问题

处理器的第21 根地址线，编号A20。“A”是Address 的首字符，就是地址，A0 是第一根地址线，A31 是第32 根地址线，所以，A20 就是第21根地址线。



如图11-6 所示，IBM 公司使用一个与门来控制第21 根地址线A20，并把这个与门的控制阀门放在键盘控制器内，端口号是0x60。向该端口写入数据时，如果第1 位是“1”，那么，键盘控制器通向与门的输出就为“1”，与门的输出就取决于处理器A20 是“0”还是“1”。

![1724724863647](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724724863647.png)





如图11-7 所示，输入输出控制器集中芯片ICH 的处理器接口部分，有一个用于兼容老式设备的端口0x92，第7～2 位保留未用，第0 位叫做INIT_NOW，意思是“现在初始化”，用于初始化处理器，当它从0 过渡到1 时，ICH 芯片会使处理器INIT#引脚的电平变低（有效），并保持至少16 个PCI 时钟周期。通俗地说，向这个端口写1，将会使处理器复位，导致计算机重新启动

![1724724925307](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724724925307.png)

端 口 0x92 的 位 1 用 于 控 制 A20 ， 叫 做 替 代 的 A20 门 控 制 （Alternate A20 Gate ， ALT_A20_GATE），它和来自键盘控制器的A20控制线一起，通过或门连接到处理器的A20M#引脚。

**端口0x92 是可读写的，第40～42 行，先从该端口读出原数据，接着，将第2 位（位1）置“1”，然后再写入该端口，这样就打开了A20。**









### 保护模式下的内存访问

实模式和保护模式，控制这两种模式切换的开关原是在一个叫CR0 的寄存器。CR0 是处理器内部的控制寄存器（Control Register，CR）。

CR0 是32 位的寄存器，包含了一系列用于控制处理器操作模式和运行状态的标志位。如图11-8 所示，它的第1 位（位0）是保护模式允许位（Protection Enable，PE），是开启保护模式大门的门把手，如果把该位置“1”，则处理器进入保护模式，按保护模式的规则开始运行。

![1724725250310](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724725250310.png)



保护模式下的中断机制和实模式不同，因此，原有的中断向量表不再适用，而且，必须要知道的是，在保护模式下，BIOS 中断都不能再用，因为它们是实模式下的代码。**在重新设置保护模式下的中断环境之前，必须关中断**，这就是第44 行的用意。





如图11-9 所示，32 位处理器的这6 个段寄存器又分为两部分，前16位和8086 相同，在实模式下，它们用于按传统的方式寻址1MB 内存，使用方法也没有变化，所以使得8086 的程序可以继续在32 位处理器上运行。同时，每个段寄存器还包括一个不可见的部分，称为**描述符高速缓存器**，用来存放段的线性基地址、段界限和段属性。

![1724725398867](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724725398867.png)





在保护模式下，尽管访问内存时也需要指定一个段，但传送到**段选择器**的内容不是逻辑段地址，而是段描述符在描述符表中的索引号。

如图11-10 所示，在保护模式下访问一个段时，传送到段选择器的是**段选择子**。它由三部分组成，第一部分是**描述符的索引号**，用来在描述符表中选择一个段描述符。**TI** 是描述符表指示器（Table Indicator），TI＝0 时，表示描述符在GDT 中；TI＝1 时，描述符在LDT 中。。**RPL** 是请求特权级，表示给出当前选择子的那个程序的特权级别，正是该程序要求访问这个内存段。每个程序都有特权级别

![1724725541306](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724725541306.png)







如图11-11 所示，当处理器在执行任何改变段选择器的指令时（比如pop、mov、jmp far、call far、iret、retf），就将指令中提供的索引号乘以8 作为偏移地址，同GDTR 中提供的线性基地址相加，以访问GDT。如果没有发现什么问题（比如超出了GDT 的界限），就自动将找到的描述符加载到不可见的描述符高速缓存部分。

此后，每当有访问内存的指令时，就不再访问GDT 中的描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址。

![1724725631015](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724725631015.png)





如图11-12所示，执行这条指令时，处理器用**DS 描述符高速缓存**中的线性基地址加上指令中给出的偏移量0x00，形成32 位物理地址0x000b8000，并将字符“P”的ASCII 码写入该处。

![1724725749194](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724725749194.png)





如图11-13 所示，在32 位保护模式下，处理器使用的指令指针寄存器是EIP。假设已经从描述符表中选择了一个段描述符，**CS 描述符高速缓存器**已经装载了正确的32 位线性基地址，那么，当处理器取指令时，会自动用描述符高速缓存器中的32 位线性基地址加上指令指针寄存器EIP 中的32 位偏移量，形成32 位物理地址，从内存中取得执令并加以执行。同时，EIP 的内容自动增加以指向下一条指令。当前指令执行完毕之后，处理器接着按上述方式取下一条指令加以执行。

![1724725824332](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724725824332.png)









### 清空流水线并串行化处理器

这里有两个亟待解决的问题。

- 第一，正如上一节所述，即使是在实模式下，段寄存器的描述符高速缓存器也被用于访问内存，仅低20 位有效，高12 位是全零。当处理器进入保护模式后，这些内容依然残留着，但不影响使用，程序可以继续执行。但是，这些残留的内容在保护模式下是无效的，迟早会在执行某些指令的时候出问题。因此，比较安全的做法是尽快刷新CS、SS、DS、ES、FS 和GS 的内容，包括它们的段选择器和描述符高速缓存器。
- 第二，在进入保护模式前，有很多指令已经进入了流水线。因为处理器工作在实模式下，所以它们都是按16 位操作数和16 位地址长度进行译码的，即使是那些用bits 32 编译的指令。进入保护模式后，受CS 段描述符高速缓存器中实模式残留内容的影响，处理器进入16 位保护模式工作。如果保护模式下的代码是16 位的，影响可能不大，但如果是用bits 32 编译的，那么，由于对对操作数和默认地址大小的解释不同，指令的执行结果可能会不正确，所以必须清空流水线。同时，那些通过乱序执行得到的中间结果也是无效的，必须清理掉，让处理器串行化执行，即，重新按指令的自然顺序执行。

这里有一个两全其美的方案，那就是使用**远转移指令jmp或者远过程调用指令call**。处理器最怕转移指令，遇到这种指令，一般会**清空流水线，并串行化执行**；另一方面，远转移会重新加载段选择器CS，并刷新描述符高速缓存器中的内容。

一个建议的方法是在设置了控制寄存器CR0 的PE 位之后，立即用jmp 或者call 转移到当前指令流的下一条指令上。



注意，在保护模式下，不允许使用mov 指令改变段寄存器CS 的内容，比如：`mov cs,ax`

企图这样做将导致处理器产生一个无效操作码的异常中断







### 保护模式下的栈

第77～79 行用于初始化保护模式下的栈。栈段描述符是GDT 中的第4 个（3 号）描述符，栈的32 位线性基地址是0x00000000，段界限为0x07a00，粒度为字节，属于可读可写、向下扩展的数据段。



在32 位代码中，是用ESP 作为栈指针的。因此，这里的段界限，用来和段粒度一起，决定ESP 寄存器所能具有的最小值。即，栈操作时，必须符合条件：

```assembly
ESP > 段界限X粒度值
```





你可能觉得当前的栈段很完美。但不得不说，这是一个非常糟糕的栈定义。结合本章的程序，很明显，我们的本意是要定义一个只有512字节的栈空间，从物理地址0x00007A00 开始，到物理地址0x00007C00结束，如图11-14 所示。

![1724726354260](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724726354260.png)











## 第12章 存储器的保护

处理器引入保护模式的目的是提供保护功能，其中很重要的一个方面就是存储器保护。存储器的保护功能可以禁止程序的非法内存访问，比如，向代码段写入数据、访问段界限之外的内存位置等。

凡事都有两面。利用存储器的保护功能，也可以实现一些有价值的功能，比如虚拟内存管理。当处理器访问一个实际上不存在的段时，会引发异常中断。操作系统可以利用这一点，通过接管异常处理过程，并用硬盘来进行段的换入和换出，从而实现在较小的内存空间运行尽可能大、尽可能多的程序。







### 进入32 位保护模式

#### 话说mov ds,ax 和mov ds,eax

**段寄存器（选择器）的值**只能用**内存单元或者通用寄存器**来传送，一般的指令格式为

```assembly
mov sreg,r/m16
```

在16 位模式下，默认的操作数大小是字（2 字节），在32 位模式下，默认的操作数大小是双字（4 字节）。

代码清单12-1 第7、8 行，用于通过寄存器EAX 来初始化栈段寄存器SS。





#### 创建GDT 并安装段描述符

如图12-1，本章程序中各个部分在内存中的分布

![1724921710496](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724921710496.png)



准备进入保护模式。

首先是创建GDT，并安装刚进入保护模式时就要使用的描述符。

- 第21、22 行，安装空描述符。该描述符的槽位号是0，处理器不允许访问这个描述符，任何时候，使用索引字段为0 的选择子来访问该描述符，都会被处理器阻止，并引发异常中断。
- 第25、26 行，安装保护模式下的数据段描述符。参考前面的段描述符格式，可以看出，该段的线性基地址位于整个内存的最低端，为0x00000000；属于32 位的段，段界限是0xFFFFF。但是要注意，段的粒度是以4KB 为单位的。
- 第29、30 行，安装保护模式下的代码段描述符。该段是32 位的代码，线性基地址为0x00007C00；段界限为0x001FF，粒度为字节。
- 第33、34 行，安装保护模式下的数据段描述符。该段是32 位的数据段，线性基地址为0x00007C00；段界限为0x001FF，粒度为字节。
- 第36、37 行，安装保护模式下的栈段描述符。该段的线性基地址是0x00007C00，段界限为0xFFFFE，粒度为4KB。
- 第40 行，设置GDT 的界限值为39，因为这里共有5 个描述符，总大小为40 字节，界限值为39。









### 修改段寄存器时的保护

随着程序的执行，经常要对段寄存器进行修改。此时，处理器在变更段寄存器以及隐藏的描述符高速缓存器的内容时，要检查其代入值的合法性。

代码清单12-1 第55 行，这是一条直接远转移指令：

```assembly
jmp dword 0x0010:flush
```

这条指令会隐式地修改段寄存器CS。



指令涉及段寄存器的修改，处理器把指令中给出的选择子传送到段寄存器的选择器部分。但是，处理器的固件在完成传送之前，要确认选择子是正确的，并且该选择子选择的描述符也是正确的。

- 如图12-2 所示，GDT的基地址和界限，都在寄存器GDTR 中。处理器从GDT 中取某个描述符时，就要求描述符的8 个字节都在GDT 边界之内，也就是索引号×8＋7 小于等于边界。

  ![1724922013833](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724922013833.png)

- 如果检查到指定的段描述符，其位置超过表的边界时，处理器中止处理，产生异常中断13，同时段寄存器中的原值不变。

- 通过了上述检查，并从表中取得描述符后，紧接着还要对描述符的类别进行确认。

  - 举个例子来说，若描述符的类别是只执行的代码段（表11-1），则不允许加载到除CS 之外的其他段寄存器中。

- 然后，检查描述符的类别是否和段寄存器的用途匹配。

- 最后，除了按表12-1 进行段的类别检查外，还要检查描述符中的P位。

  - 如果P＝0，表明虽然描述符已被定义，但该段实际上并不存在于物理内存中。此时，处理器中止处理，引发异常中断11。
  - 如果P＝1，则处理器将描述符加载到段寄存器的描述符高速缓存器，同时置A 位。

- 一旦上述规则全部验证通过，处理器就将选择子加载到段寄存器的选择器。









### 地址变换时的保护

#### 代码段执行时的保护

**处理器的检查规则：**

在32 位模式下，尽管段的信息在描述符表中，但是，一旦相应的描述符被加载到段寄存器的描述符高速缓存器，则处理器取指令和执行指令时，将不再访问描述符表，而是直接使用段寄存器的描述符高速缓存器，从中取得线性基地址，同指令指针寄存器EIP 的内容相加，共同形成32位的物理地址从内存中取得下一条指令。不过，在指令实际开始执行之前，处理器必须检验其存放地址的有效性，以防止执行超出允许范围之外的指令。

每个代码段都有自己的段界限，位于其描述符中。**实际使用的段界限**，其数值和粒度（G）位有关，如果G＝0，实际使用的段界限就是描述符中记载的段界限；如果G＝1，则**实际使用的段界限**为
$$
描述符中的段界限值 * 0x1000 + 0xFFF
$$
代码段是向上（高地址方向）扩展的，因此，实际使用的段界限就是当前段内最后一个允许访问的偏移地址。当处理器在该段内取指令执行时，偏移地址由EIP 提供。指令很有可能是跨越边界的。因此，要执行的那条指令，其长度减1 后，与EIP 寄存器的值相加，结果必须小于等于实际使用的段界限，**否则引发处理器异常**。即：
$$
0 <= (EIP + 指令长度 - 1) <= 实际使用的段界限
$$


**案例：**

在本章中，代码段描述符中给出的**界限值是`0x001FF`，粒度是字节**，可以认为它就是段内最后一个允许访问的偏移地址。如图12-3 所示，在处理器取得一条指令后，EIP 寄存器的数值加上该指令的长度减1，得到的结果必须小于等于`0x000001FF`，如果等于或者超出这个数值，必然引发异常中断。

![1724934671859](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724934671859.png)

任何指令都不允许，也不可能向代码段写入数据。而且，只有在代码段可读的情况下（由其描述符指定），才能由指令读取其内容。







#### 栈操作时的保护

**处理器的检查规则：**

在保护模式下操作时，栈是一个容易令人感到迷惑的话题。栈段一直是使用向下扩展的内存段，段界限的检查和向上扩展的数据段和代码段不同。

对栈操作的指令一般是`push, pop, ret, iret `等。这些指令在代码段中执行，但实际操作的却是栈段。

现在只讨论**32 位的栈段，即，其描述符B 位是1 的栈段**。处理器在这样的段上执行压栈和出栈操作时，**默认使用ESP 寄存器**。在栈段中，实际使用的段界限也和粒度（G）位相关，如果G＝0，实际使用的段界限就是描述符中记载的段界限；如果G＝1，则**实际使用的段界限**为
$$
描述符中的段界限值 * 0x1000+0xFFF
$$
栈段是向下扩展的，每当往栈中压入数据时，ESP 的内容要减去操作数的长度。所以，和向高地址方向扩展的段相比，非常重要的一点就是，实际使用的段界限就是段内不允许访问的最低端偏移地址。至于最高端的地址，则没有限制，最大可以是`0xFFFFFFFF`。也就是说，在进行栈操作时，必须符合以下规则：
$$
实际使用的段界限+1 <= (ESP的内容-操作数的长度) <= 0xFFFFFFFF
$$






**案例：**

回到本章中，看代码清单12-1 第67～69 行。这三行设置栈的线性基地址为`0x00007C00`，段界限为`0xFFFFE`，粒度为`4KB`，并设置栈指针`寄存器ESP` 的初值为0。
因为段界限的粒度是4KB（G＝1），**套用公式，故实际使用的段界限为**
$$
实际使用的段界限 =0xFFFFE * 0x1000 +0xFFF = 0xFFFFEFFF
$$
又因为ESP 的最大值是`0xFFFFFFFF`，因此，如图12-4 所示，**套用公式，在操作该段时，处理器的检查规则是**：
$$
LowerBoundary = 实际使用的段界限+1 = 0xFFFFF000 \\
UpperBoundary = 0xFFFFFFFF \\
0xFFFFF000 <= (ESP的内容-操作数的长度) <= 0xFFFFFFFF
$$
栈指针寄存器ESP 的内容仅仅在访问栈时提供偏移地址，操作数在压入栈时的物理地址要用段寄存器的描述符高速缓存器中的段基址和ESP 的内容相加得到。因此，该栈最低端的有效物理地址是

```assembly
0x00007C00 + 0xFFFFF000 = 0x00006C00
```

最高端的有效物理地址是

```assembly
0x00007C00 + 0xFFFFFFFF = 0x00007BFF
```

**以上地址计算利用了32位CPU的溢出**

![1724934853395](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1724934853395.png)







#### 数据访问时的保护

**处理器的检查规则：**

这里所说的数据段，特指向上扩展的数据段。

因为是向上扩展的，所以代码段的检查规则同样适用于数据段。不同之处仅仅在于，对于取指令来说，是否越界取决于指令的长度；而**对于数据段来说，则取决于操作数的尺寸**。

当处理器访问数据段时，要依据以下规则进行检查：
$$
0 <= (EA+操作数大小-1) <= 实际使用的段界限
$$
在任何时候，段界限之外的访问企图都会被阻止，并引发处理器异常中断。





**案例：**

无







### 使用别名访问代码段对字符排序

接下来要做的事情是对一串散乱的字符进行排序。坦白地说，排序是假，主要目的是演示如何在保护模式下使用别名段。

字符串位于代码清单12-1 的第105 行，用标号string 声明，并初始化

这串字符是主引导程序的一部分，在进入保护模式时，它就位于32位代码段中。代码段是用来执行的，能不能读出，取决于其描述符的类别字段。但是无论如何，它都不允许写入。

我们想就地把这串字符按ASCII 码从小到大排列，涉及原地写入数据的操作。好在前面已经建立了**代码段的别名描述符**，而且用段寄存器DS 指向它。参见代码清单12-1第59、60 行。















## 第13章 程序的动态加载和执行

从某种意义上来说，保护模式的工作机制对用户程序的加载和执行非但没有增加困难，反而带来了很大的便利。

因此，本章中用于加载和处理用户程序的做法，不一定，甚至根本就不是操作系统采用的方法。这一点，务必明了。

计算机硬件之上是软件。软件分两个层次

- 应用（用户）程序。
  - 通常，用户程序只关心问题的解，就是采用各种算法来解决实际问题。至于软件是怎么加载到内存的，怎么定位的，不是它所操心的事。但是，它有义务提供一些必要的信息，来帮助操作系统将自己加载到内存中。
- 操作系统
  - 操作系统则必须考虑采用什么方法来加载用户程序，并在适当的时候将处理器的执行流转移到用户代码中去。同时，为了减轻用户程序的工作量，操作系统还应当管理硬件，并提供大量的例程供用户程序使用。

操作系统和用户程序应当协商一种机制，让用户程序能够在使用这些例程时，不必考虑和关心它们的位置。



本章提供了一个小小的“操作系统”，因为当不起这么大的名称，所以叫“内核”或者“核心”。

内核不能放到主引导扇区里，毕竟它都很大。所以：

- 计算机首先从主引导程序开始执行，主引导程序负责加载内核，并转交控制权。
- 然后，内核负责加载用户程序，并提供各种例程给用户程序调用。
  - 提供给用户程序调用的例程也叫应用程序接口（Application Programming Interface，API）







### 内核的结构、功能和加载

#### 内核的结构

内核分为四个部分，分别是初始化代码、内核代码段、内核数据段和公共例程段，主引导程序也是初始化代码的组成部分。

初始化代码，初始化代码大部分位于代码清单13-1 中。

- 用于从BIOS 那里接管处理器和计算机硬件的控制权，安装最基本的段描述符，初始化最初的执行环境。
- 然后，从硬盘上读取和加载内核的剩余部分，创建组成内核的各个内存段。





**内核的代码和数据**位于代码清单13-2 中。如图13-1 所示，

![1725005931228](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725005931228.png)

- **内核代码段**是在第385 行定义的，用于分配内存，读取和加载用户程序，控制用户程序的执行
- **内核数据段**是在第330 行定义的，提供了一段可读写的内存空间，供内核自己使用。
- **公共例程段**是在第34 行定义的，用于提供各种用途和功能的子过程以简化代码的编写。这些例程既可以用于内核，也供用户程序调用。
- 除了以上的内容之外，内核文件还包括一个**头部**，记录了各个段的汇编位置，这些统计数据用于告诉初始化代码如何加载内核。







#### 内核的加载

现在来看代码清单13-1，也就是主引导程序。





本章内存布局，如 图 13-2 所 示 ：

- 因 为 主 引 导 程 序 的 加 载 位 置 是 物 理 地 址`0x00007C00`，所以，从这个位置往上是512 字节的**初始化代码段**
- 从这个位置，`0x00007C00`，往下是4KB 的**内核栈**
- **全局描述符表（GDT）**是不可或缺的，我们将它定义在从物理地址`0x00007E00`开始的地方，紧挨着初始化代码段。
- **内核程序**的大小也是不定的，但可以规定它的起始位置。在这里，我们决定将它加载到从物理内存地址`0x00040000` 开始的地方。
- 显示器是窥视程序工作的窗口，显示功能自然少不了。因此，从`0x000B8000` 往上的32KB，是**文本模式的显示缓冲区**。
- 最后，从`1MB` 开始的大量空间是留给**用户程序**用的，具体数量取决于你到底安装了多少物理内存。

![1725006130744](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725006130744.png)





在进入保护模式之前，初始化程序（主引导程序）已经在全局描述符表（GDT）中安装了几个必要的描述符。如图13-3 所示，

- 第一个是用于访问0~4GB 内存的数据段，它很重要，内核只有在具备了访问全部4GB 内存空间的能力时，才能随心所欲地做任何事情。
- 第二个是初始化代码段，也就是主引导程序所在的段。进入保护模式后，要继续执行主引导程序的后半部分代码，必须按处理器的要求，为它创建描述符。
- 最后两个分别是初始的栈段和显示缓冲区的描述符。这里定义的栈在初始化过程中就要使用，而在进入内核之后，它又是内核的栈。

![1725006597402](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725006597402.png)





下面开始加载内核：

- 首先是初始化各个段寄存器以访问相应的内存段。第59、60 行，使DS 指向全部4GB 的内存空间；第62～64 行，使SS 指向初始的栈空间，并初始化栈指针寄存器ESP 的内容为0。
- 接下来是从硬盘把内核程序读入内存，第67～69 行，它在硬盘上的起始逻辑扇区号和物理内存地址已经由两个常数给出，现分别将它们传送到EAX 和EDI 寄存器。
- 第87～93 行，用于从硬盘读取剩余的扇区，用的是loop 指令循环读取，循环的次数在ECX寄存器中。再重复一遍，**32 位模式下的循环指令需要使用ECX 寄存器** ，而不是CX。









#### 安装内核的段描述符

要使内核工作起来，首要的任务是为它的各个段创建描述符。换句话说，还要为GDT 续添新的描述符。

现在，我们的任务是重新从标号pgdt 处取得GDT 的基地址，为其添加描述符，并修改它的大小，然后用lgdt 指令重新加载一遍GDTR 寄存器，使修改生效。

标号pgdt 所指向的内存区域位于主引导程序内，而我们当前正在保护模式下执行主引导程序。保护模式下的代码段只是用来执行的，是否能读出，取决于其描述符的类别字段，但无论如何它都不能写入。

对代码段实施保护的意思是通过代码段描述符不能修改段中的内容，但不意味着通过其他描述符做不到。想想看，我们拥有一个指向全部4GB 内存空间的描述符，标号pgdt 所指向的内存位置不单单是在主引导程序内，同时也是4GB 内存空间的一部分。

如图13-4 所示，标号pgdt 在数值上等于它距离段首的偏移量，也就是编译阶段的汇编地址。主引导程序的物理起始地址是0x00007C00，故pgdt 在4GB 段内的偏移量是0x00007C00＋pgdt。

这样，为了得到GDT 的基地址，代码清单13-1 第96 行，使用了指令

```assembly
mov esi,[0x7c00+pgdt+0x02]
```

![1725007059723](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725007059723.png)





现在可以创建与内核相关的其他段描述符。首先是公共例程段。如图13-5 所示，内核头部偏移0x04 处的一个双字，就是公共例程段的起始汇编地址。由于内核被加载的物理地址是由EDI 寄存器指向的，所以，第99 行，直接访问4GB 内存段，从该偏移位置取出公共例程段的起始汇编地址。

![1725007104790](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725007104790.png)





至此，内核已经全部加载完毕，图13-7 是内核加载完成之后的GDT布局。

![1725007155368](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725007155368.png)







### 在内核中执行

现在转到代码清单13-2，这是内核的主体部分。

从主引导程序转移到内核之后，处理器会从第532 行开始执行，因为这里是内核的入口。



**cpuid 指令（CPU Identification）用于返回处理器的标识和特性信息**。EAX 用于指定要返回什么样的信息，也就是功能。有时候，还要用到ECX 寄存器。cpuid 指令执行后，处理器将返回的信息放在EAX、EBX、ECX 或者EDX 中。

如图13-8 所示，在32 位处理器上，原先的标志寄存器FLAGS 也相应地扩充到了32 位，以支持更多的标志。扩充之后的标志寄存器称为EFLAGS 寄存器，它的ID 标志位（位21）如果为“0”，则不支持cpuid 指令；反之，该处理器支持cpuid 指令。

![1725007302849](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725007302849.png)









### 用户程序的加载和重定位

好了，现在我们可以开始加载用户程序了。





#### 用户程序的结构

**用户程序必须符合规定的格式，才能被内核识别和加载**。通常情况下，流行的**操作系统会规定自己的可执行文件格式**，一般都比较复杂，这种复杂性和操作系统自身的复杂性是息息相关的。

现在转到代码清单13-3，来看看用户程序的结构。

所有操作系统的**可执行文件**都包括**文件头**

- 在文件头内的偏移0 处，是一个双字，**指示了用户程序的大小**，以字节为单位。
- 偏移量为0x04 处的双字是**头部的长度**，以字节为单位。
- 偏移量为0x08 处的双字是为**栈**保留的，
  - 和早先的做法不同，内核不要求用户程序提供栈空间，而改由内核动态分配，以减轻用户程序编写的负担。当内核分配了栈空间后，会把栈段的选择子填写到这里，用户程序开始执行时，可以从这里取得该选择子以初始化自己的栈
- 偏移量为0x0c 处的双字是要求分配的栈大小，即，**用户程序编写者建议的栈大小**，以4KB为单位。
- 偏移量为0x10 处的双字，是**用户程序入口点的32 位偏移地址**。
- 偏移量为0x14 处的双字，是**用户程序代码段的起始汇编地址**。
  - 当内核完成对用户程序的加载和重定位后，将把该段的选择子回填到这里（仅占用低字部分）。这样一来，它和0x10 处的双字一起，共同组成一个6 字节的入口点，内核从这里转移控制到用户程序。
- 偏移量为0x18 处的双字，是用户程序代码段的长度，以字节为单位。
- 偏移量为0x1c 处的双字，是用户程序数据段的起始汇编地址，当内核完成用户程序的加载和重定位后，将把该段的选择子回填到这里（仅占用低字部分）。
- 偏移量为0x20 处的双字，是用户程序数据段的长度，以字节为单位。





除了加载和重定位用户程序外，内核还应当提供一些**例程**供用户程序调用。操作系统，对程序员来说，则是一个巨大的例程库，节省了时间，减少了工作量，甚至不需要直接访问硬件。

为了使开发人员能够利用它所提供的API，操作系统至少要公开它们。在早期的系统中，这些API 以中断号的方式公布，因为它们是通过软中断进入的。不过，另一种常见的办法是**使用符号名**。比如，操作系统提供了一个例程，用于显示光标跟随的字符串，那么，它可以公布一个符号名：

```assembly
PrintString
```

在操作系统的开发手册中，会列出所有**符号名**。符号名在高级语言里就是**库函数名**。

回到代码清单13-3 中来。

**内核要求，用户程序必须在头部偏移量为0x28 的地方构造一个表格，并在表格中列出所有要用到的符号名**。每个符号名的长度是256 字节，不足部分用0x00 填充，这意味着每个符号名的长度最多可以是256个字符。**在用户程序加载后，内核会分析这个表格，并将每一个符号名替换成相应的内存地址，这就是过程的重定位。**为了方便起见，我们把该表格叫做 “ 符号 - 地址检索表 ” （ Symbol-Address Lookup Table ，SALT）。

每个符号名都以“@”开始，这并没有任何特殊意义，仅仅在概念上用于表示“接口”的意思。为了计算需要填充多少个0，它们都使用了相似的表达式，比如：

```assembly
times 256-($-PrintString) db 0
```

SALT 表可大可小，内核需要知道它在哪里结束。第26 行，用于初始化SALT 表的项数，也就是符号名的数量，它是用表格的总长度除以每个符号名的长度（256）得到的。

事实上，即使是大多数汇编语言，也不需要亲自**构造文件头**，那是**链接器（Linker）**的工作。但是，链接器是为流行的操作系统服务的，用于构造他们可以识别的可执行文件格式。我们不想把问题搞得太复杂，就本书的篇幅和宗旨来说，迎合“流行”所要花费的代价实在太大，管中窥豹、点到即止不是很好吗？







#### 计算用户程序占用的扇区数

再次回到代码清单13-2。

用户程序的加载是在例程load_relocate_program 内进行的，该过程需要用ESI 寄存器传入用户程序的起始逻辑扇区号。当过程返回时，在AX 寄存器内包含了指向用户头部段的选择子。





#### 简单的动态内存分配

下面的工作是把用户程序从硬盘上读到内存中。我们以前的做法是指定一个区域，比如物理地址0x100000，然后把程序加载到那里。如果要加载的程序很多，这就会成为一种需要仔细规划的工作，每个程序加载到哪里，都需要一一指定。

在流行的操作系统里，内存管理是一项重要而又严肃的工作，不用说也相当复杂。它要记住所有可以分配的内存，将它们分成块。这样，当要求分配内存时，内存管理程序将查找并分配那些大小相符的空闲块；当占用这些块的用户终止执行后，还要负责回收它们，以便再用于分配；当内存空间紧张，找不到空闲块，或者空闲块的大小不能满足需求时，内存管理程序还要负责查找那些很少被访问的块，将其中的数据移到硬盘上，腾出空间来满足当前的需求。下次当这些块再次被用到时，再用同样的办法从硬盘调回内存。

就我们目前的需求来说，只需要一个简单的内存分配程序就可以了，这就是allocate_memory 例程。

allocate_memory 例程位于代码清单13-2 的公共例程段中，它仅仅需要通过ECX 寄存器传入希望分配的字节数。当过程返回时，ECX 寄存器包含了所分配内存的起始物理地址。

allocate_memory 的内存分配策略非常简单。请看代码清单13-2 的第335 行，在内核数据段中声明了标号ram_alloc，并初始化为一个双字0x00100000，这就是可用于分配的初始内存地址。很显然，这个位置正好在1MB 之外。每次请求分配内存时，allocate_memory 过程仅简单地返回该内存单元的值，作为所分配内存的起始地址。同时，将这个值加上所分配的长度，作为下次分配的起始地址写回该内存单元。

32 位的计算机系统建议内存地址最好是4 字节对齐的，这样做的好处是访问速度最快。

过程allocate_memory 是用retf 指令返回的。因此，它只能通过远过程调用来进入。







#### 段的重定位和描述符的创建

既然用户程序已经全部读入内存，现在的任务就是根据它的头部信息来创建段描述符。



安装了用户程序头部段的描述符后，第440 行，将该段的选择子写回到用户程序头部，供用户程序在接管处理器控制权之后使用。实际上，在内核向用户程序转交控制权时，也要用到。

第443～460 行，用于重定位用户程序代码段和数据段，并创建和安装相应的描述符，整个过程都是一样的，也很容易理解。







#### 重定位用户程序内的符号地址

为了使用内核提供的例程，用户程序需要建立一个符号-地址对照表（SALT）。这样，当用户程序加载后，内核应该根据这些符号名来回填它们对应的入口地址，这称为符号地址的重定位。显然，重定位的过程就是字符串匹配和比较的过程。

为了对用户程序内的符号名进行匹配，**内核也必须建立一张符号-地址对照表（SALT）**。

**内核的SALT 表**位于代码清单13-2 的内核数据段中，从第338 行开始，一直到第357 行结束。实际上，这个表是可以根据需要扩展的。

如图13-9 所示，**用户程序内的SALT 表**，每个条目是256 字节，用于容纳符号名，不足256字节的，用零填充。**内核中的SALT 表**，每个条目则包括两部分，第一部分也是256 字节的符号名；第二部分有6 字节，用于容纳4 字节的偏移地址和2 字节的段选择子，因为符号名是用来描述例程的，这6 字节就是例程的入口地址。

![1725008629634](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725008629634.png)

在用户程序加载时，内核的任务是比对这两张SALT 表，并将用户程序SALT 表中的符号名替换成相应的入口地址。为了便于说明，用户程序的SALT 表简称U-SALT，内核的SALT 表简称C-SALT。





如图13-10 所示，为了重定位U-SALT，我们打算用DS:ESI 指向CSALT，用ES:EDI 指向USALT。第477、478 行，访问4GB 内存段，从用户程序头部偏移为0x04 的地方取出刚刚安装好的头部段选择子，并使段寄存器ES 指向用户程序头部段，因为U-SALT 位于用户程序头部段内。

![1725008693665](../X86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/1725008693665.png)







### 执行用户程序

在load_relocate_program 过程的最后，第517 行，把用户程序头部段的选择子传送到AX 寄存器。第519～528 行，从栈中弹出并恢复各个寄存器的原始内容，并返回到调用者。AX 寄存器中的选择子是作为参数返回到主程序的。主程序将用它来找到用户程序的入口，并从那里进入。











## 第14章 任务和特权级保护

在保护模式下，通过将内存分成大小不等的段，并用描述符对每个段的用途、类型和长度进行指定，就可以在程序运行时由处理器硬件施加访问保护。

当一个程序老老实实地访问只属于它自己的段时，基本的段保护机制是很有效的。但是，一个失控的程序，或者一个恶意的程序，依然可以通过追踪和修改描述符表来达到它们访问任何内存位置的目的。

多任务系统，对任务之间的隔离和保护，以及任务和操作系统之间的隔离和保护都提出了要求，这可以看做对段保护机制的进一步强化。同时，在多任务系统中，操作系统居于核心软件的位置，为各个任务服务，负责任务的加载、创建和执行环境的管理，并执行任务之间的调度，对操作系统的保护显得尤为重要。









### 任务的隔离和特权级保护

#### 任务、任务的LDT 和TSS

程序（Program）是记录在载体上的指令和数据，总是为了完成某个特定的工作，其**正在执行中的一个副本，叫做任务（Task）**。



如图14-1 所示，为了有效地在任务之间实施隔离，处理器建议每个任务都应当具有自己的描述符表，称为**局部描述符表LDT（Local Descriptor Table）**，并且把专属于自己的那些段放到LDT中。

和GDT 一样，LDT 也是用来存放描述符的。不同之处在于，LDT 只属于某个任务。或者说，每个任务都有自己的LDT，每个任务私有的段，都应当在LDT 中进行描述。另外，LDT 的第1 个描述符，也就是0号槽位，也是有效的、可以使用的

![1725242967752](assets/1725242967752.png)

局部描述符表（LDT）的数量则不止一个，具体有多少，视任务的多少而定。为了追踪和访问这些LDT，处理器使用了**局部描述符表寄存器（LDT Register：LDTR）**。

在一个多任务的系统中，会有很多任务在轮流执行，**正在执行中的那个任务，称为当前任务（Current Task）**。因为LDTR 寄存器只有一个，所以，它只用于指向当前任务的LDT。**每当发生任务切换时，LDTR的内容被更新，以指向新任务的LDT**。和GDTR 一样，LDTR 包含了32位线性基地址字段和16 位段界限字段，以指示当前LDT 的位置和大小。





**在一个多任务的环境中，当任务切换发生时，必须保护旧任务的运行状态，或者说是保护现场**，保护的内容包括通用寄存器、段寄存器、栈指针寄存器ESP、指令指针寄存器EIP、状态寄存器EFLAGS，等等。否则的话，等下次该任务又恢复执行时，一切都会变得茫然而毫无头绪。

为了保存任务的状态，并在下次重新执行时恢复它们，每个任务都应当用**一个额外的内存区域**保存相关信息，这叫做**任务状态段（TaskState Segment：TSS）**。如图14-2 所示，任务状态段TSS 具有固定的格式，最小尺寸是104 字节，图中所标注的偏移量是十进制的 。**处理器固件能够识别TSS 中的每个元素，并在任务切换的时候读取其中的信息。**

![1725243257045](assets/1725243257045.png)

处理器用**TR 寄存器**来指向当前任务的TSS。和GDTR、LDTR 一样，TR 寄存器在处理器中也只有一个。**当任务切换发生的时候，TR 寄存器的内容也会跟着指向新任务的TSS。**









#### 全局空间和局部空间

在多任务系统中，操作系统肩负着任务的创建，以及在任务之间调度和切换的工作。



如图14-3 所示，每个任务实际上包括两个部分：全局部分和私有部分。全局部分是所有任务共有的，含有操作系统的软件和库程序，以及可以调用的系统服务和数据；私有部分则是每个任务各自的数据和代码，与任务所要解决的具体问题有关，彼此并不相同。

![1725243414061](assets/1725243414061.png)

任务实际上是在内存中运行的，所以，所谓的全局部分和私有部分，其实是地址空间的划分，即全局地址空间和局部地址空间，简称全局空间和局部空间。

**地址空间的访问是依靠分段机制来进行的。具体地说，需要先在描述符表中定义各个段的描述符，然后再通过描述符来访问它们。因**此，全局地址空间是用全局描述符表（GDT）来指定的，而局部地址空间则是由每个任务私有的局部描述符表（LDT）来定义的。



**段寄存器（CS、SS、DS、ES、FS 和GS）**由16 位的**选择器**和不可见的**描述符高速缓存器**组成。选择器的位2 是表指示器TI，若TI＝0，指向GDT，表示当前正在访问的段描述符位于GDT 中；否则指向LDT，表示当前正在访问的段描述符位于LDT 中。



操作系统允许程序的编写者使用虚拟地址或者逻辑地址来访问内存，就像他真的拥有这么巨大的地址空间一样。

上面一段话可以这样理解：编译器不考虑处理器可寻址空间的大小，也不考虑物理内存的大小，它只是负责编译程序。

同一块物理内存，可以让多个任务，或者每个任务的不同段来使用。当执行或者访问一个新的段时，如果它不在物理内存中，而且也没有空闲的物理内存空间来加载它，那么，操作系统将挑出一个暂时用不到的段，把它换出到磁盘中，并把那个腾出来的空间分配给马上要访问的段，并修改段的描述符，使之指向这段内存空间。下一次，当被换出的那个段马上又要用到时，再按相同的办法换回到物理内存。所有这一切，任务（如果它有思维的话）和程序的编写者是不必关心的，这就是虚拟内存管理的一般方法。









#### 特权级保护概述

引入LDT 和TSS，只是从任务层面上进一步强化了分段机制，从安全保障的角度来看，只相当于构建了可靠的硬件设施。

在分段机制的基础上，处理器引入了特权级，并由固件负责实施特权级保护。

**特权级（Privilege Level）**，也叫特权级别，是存在于**描述符**及其**选择子**中的一个数值，当这些描述符或者选择子所指向的对象要进行某种操作，或者被别的对象访问时，该数值**用于控制它们所能进行的操作，或者限制它们的可访问性。**

Intel 处理器可以识别4 个特权级别，分别是0 到3，较大的数值意味着较低的特权级别，反之亦然。如图14-4 所示，这是Intel 处理器所提供的4 级环状保护结构。

![1725243921723](assets/1725243921723.png)

**操作系统**是为所有程序服务的，可靠性最高，而且必须对软硬件有完全的控制权，所以它的主体部分必须拥有特权级0，并处于整个环形结构的中心。也正是因为这样，**操作系统的主体部分通常又被称做内核（Kernel、Core）**。

特权级1 和2 通常赋予那些可靠性不如内核的系统服务程序，比较典型的就是**设备驱动程序**。当然，在很多比较流行的操作系统中，**驱动程序**与内核的特权级别相同，都是0。

**应用程序**的可靠性被视为是最低的，而且通常不需要直接访问硬件和一些敏感的系统资源，调用设备驱动程序或者操作系统例程就能完成绝大多数工作，故**赋予它们最低的特权级别3**。





**实施特权级保护的第一步，是为所有可管理的对象赋予一个特权级，以决定谁能访问它们。**

每个描述符都有一个两比特的DPL 字段，可以取值为00、01、10 和11，分别对应特权级0、1、2 和3。DPL 是每个描述符都有的字段，故又称**描述符特权级（Descriptor Privilege Level）**。描述符总是指向它所描述的目标对象，代表着该对象，因此，该字段实际上是目标对象的特权级。





当处理器正在一个**代码段**中取指令和执行指令时，那个**代码段的特权级**叫做**当前特权级（Current Privilege Level，CPL）**。正在执行的这个代码段，其选择子位于段寄存器CS 中，其最低两位就是当前特权级的数值

应用程序编写时，不需要考虑GDT、LDT、分段、描述符这些东西，它们是在程序加载时，由操作系统负责创建的，应用程序的编写者只负责具体的功能就可以了。**应用程序的加载和开始执行，也是由操作系统所主导的，而操作系统一定会将它放在特权级3 上**。当应用程序开始执行时，当前特权级CPL 自然就会是3。

这实际上就是把一个任务分成特权级截然不同的两个部分，**全局部分是特权级0 的，而局部空间则是特权级3 的**。这种划分是有好处的，全局空间是为所有任务服务的，其重要性不言而喻。为了保证它的安全性，并能够访问所有软硬件资源，应该使它拥有最高的特权级别。当任务在自己的局部空间内执行时，当前特权级CPL 是3；当它通过调用系统服务，进入操作系统内核，在全局空间执行时，当前特权级CPL 就变成了0。

**计算机系统的脆弱性在于一条指令就能改变它的整体运行状态，比如停机指令hlt 和对控制寄存器CR0 的写操作，像这样的指令只能由最高特权级别的程序来做。**因此，那些只有在当前特权级CPL 为0 时才能执行的指令，称为特权指令（Privileged Instructions）。典型的特权指令包括加载全局描述符表的指令lgdt（它在实模式下也可执行）、加载局部描述符表的指令lldt、加载任务寄存器的指令ltr、读写控制寄存器的mov 指令、停机指令hlt 等十几条。

除了那些特权级敏感的指令外，处理器还允许对各个特权级别所能执行的I/O 操作进行控制。通常，这指的是端口访问的许可权，因为对设备的访问都是通过端口进行的。如图14-5 所示，在处理器的标志寄存器
EFLAGS 中，位13、位12 是**IOPL 位，也就是输入/输出特权级（I/OPrivilege Level），它代表着当前任务的I/O 特权级别**

![1725246408810](assets/1725246408810.png)

![1725246419241](assets/1725246419241.png)

任务是由操作系统加载和创建的，与任务相关的信息都在它自己的任务状态段（TSS）中，其中就包括一个EFLAGS 寄存器的副本，用于指示与当前任务相关的机器状态，比如它自己的I/O特权级IOPL。在多任务系统中，随着任务的切换，前一个任务的所有状态被保存到它自己的TSS中，新任务的各种状态从其TSS 中恢复，包括EFLAGS 寄存器的值。

处理器不限制0 特权级程序的I/O 访问，它总是允许的。但是，可以限制低特权级程序的I/O访问权限。这是很重要的，操作系统的功能之一是设备管理，它可能不希望应用程序拥有私自访问外设的能力。





代码段的特权级检查是很严格的。一般来说，**控制转移**只允许发生在两个特权级相同的代码段之间。不过，为了让特权级低的应用程序可以调用特权级高的操作系统例程，处理器也提供了相应的解决办法。

第一种方法是将高特权级的代码段定义为依从的。

- 代码段描述符的TYPE字段有C 位，如果C＝0，这样的代码段只能供同特权级的程序使用；
- 否则，如果C＝1，则这样的代码段称为依从的代码段，可以从特权级比它低的程序调用并进入。

但是，即使是将控制转移到依从的代码段，也是有条件的，要求当前特权级CPL 必须低于，或者和目标代码段描述符的DPL 相同。即，在数值上，

```assembly
CPL >= 目标代码段描述符的DPL
```

**依从的代码段不是在它的DPL 特权级上运行，而是在调用程序的特权级上运行。**就是说，当控制转移到依从的代码段上执行时，不改变当前特权级CPL，段寄存器CS 的CPL 字段不发生变化，被调用过程的特权级依从于调用者的特权级，这就是为什么它被称为“依从的”代码段。



**另一种在特权级之间转移控制的方法是使用门**。门（Gate）是另一种形式的描述符，称为**门描述符**，简称门。**门描述符则用于描述可执行的代码，比如一段程序、一个过程（例程）或者一个任务。**

门的类型有好几种：

- 不同特权级之间的**过程调用**可以使用**调用门**；
- **中断门/陷阱门**是作为中断处理过程使用的；
- **任务门**对应着单个的任务，用来执行任务切换。

在调用门描述符中，定义了目标过程（例程）所在代码段的选择子，以及段内偏移。要想通过调用门进行控制转移，可以使用`jmp far` 或者`call far `指令，并把**调用门描述符的选择子**作为操作数。

- 使用`jmp far` 指令，可以将控制通过门转移到比当前特权级高的代码段，但不改变当前特权级别。
- 如果使用`call far` 指令，则当前特权级会提升到目标代码段的特权级别。也就是说，处理器是在目标代码段的特权级上执行的。
- 除了从高特权级别的例程（通常是操作系统例程）返回外，不允许从特权级高的代码段将控制转移到特权级低的代码段，因为操作系统不会引用可靠性比自己低的代码。





**特权级保护机制只在保护模式下才能启用，而进入保护模式的方法是设置CR0 寄存器的PE位。**而且，处理器建议，在进入保护模式后，执行的第一条指令应当是跳转或者过程调用指令，以清空流水线和乱序执行的结果，并串行化处理器，就像这样：

```assembly
jmp dword 0x0010:flush
```

**RPL** 的意思是**请求特权级（Requested Privilege Level）**。我们知道，**要将控制从一个代码段转移到另一个代码段，通常是使用`jmp 和call`指令，并在指令中提供目标代码段的选择子，以及段内偏移量（入口**
**点）。**而为了访问内存中的数据，也必须先将段选择子加载到段寄存器DS、ES、FS 或者GS 中。**不管是实施控制转移，还是访问数据段，这都可以看成是一个请求，请求者提供一个段选择子，请求访问指定的段。**从这个意义上来说，**RPL 也就是指请求者的特权级别（Requestor’s Privilege Level）**。

在绝大多数时候，请求者都是当前程序自己，因此，**CPL＝RPL**。**要判断请求者是谁，最简单的方法就是看谁提供了选择子。**



**一个案例说明，一些情况下，RPL 和CPL 并不相同：**

但是，**在一些并不多见的情况下，RPL 和CPL 并不相同**。如图14-6所示，特权级为3 的应用程序希望从硬盘读一个扇区，并传送到自己的数据段，因此，数据段描述符的DPL 同样会是3。

![1725247571703](assets/1725247571703.png)

由于I/O 特权级的限制，应用程序无法自己访问硬盘。好在位于0 特权级的操作系统提供了相应的例程，但必须通过**调用门**才能使用，因为特权级间的控制转移必须通过门。

假设，**通过调用门使用操作系统例程时**，必须传入3 个参数，分别是**CX 寄存器中的数据段选择子**、EBX 寄存器中的段内偏移，以及EAX 中的逻辑扇区号。高特权级别的程序可以访问低特权级别的数据段，这是没有问题的。因此，操作系统例程会用传入的数据段选择子代入段寄存器，以便代替应用程序访问那个段：

```assembly
mov ds,cx
```

在执行这条指令时，CX 寄存器中的段选择子，其RPL 字段的值是3，**当前特权级CPL 已经变成0，因为通过调用门实施控制转移可以改变当前特权级**。显然，请求者并非当前程序，而是特权级为3 的应用程序，RPL 和CPL 并不相同。



**一个案例说明，引入RPL的必要性：**

如图14-7 所示，人类的可恶之处是无孔不入，总爱钻空子。想象一下，**应用程序的编写者通过钻研，知道了操作系统数据段的选择子，而且希望用这个选择子访问操作系统的数据段**。当然，他不可能在应用程
序里访问操作系统数据段，因为那个数据段的DPL 为0，而应用程序工作时的当前特权级为3，处理器会很机警地把来访者拒之门外。

![1725248139250](assets/1725248139250.png)

**但是，他可以借助于调用门。调用门工作在目标代码段的特权级上，一旦处理器的执行流离开应用程序，通过调用门进入操作系统例程时，当前特权级从3 变为0**。当那个不怀好意的程序将一个指向操作系统数据段的选择子通过CX 寄存器作为参数传入调用门时，因为当前特权级已经从3 变为0，可以从硬盘读出数据，并且允许向操作系统数据段写入扇区数据，他得逞了！

处理器的智商很低，它不可能知道谁是真正的请求者。因此，当指令`mov ds,ax`或者`mov ds,cx`执行时，**AX 或者CX 寄存器中的选择子可能是操作系统自己提供的，也可能来自于恶意的用户程序，这两种情况要区别对待，但已经超出了处理器的能力和职权范围。**

怎么办？

看得出来，**单纯依靠处理器硬件无法解决这个难题，但它可以在原来的基础上多增加一种检查机制，并把如何能够通过这种检查的自由裁量权交给软件（的编写者）。**



引入请**求特权级（RPL）**的原因是**处理器在遇到一条将选择子传送到段寄存器的指令时，无法区分真正的请求者是谁**。但是，引入RPL 本身并不能完全解决这个问题，这只是处理器和操作系统之间的**一种协议**，

- **处理器负责检查请求特权级RPL，判断它是否有权访问，但前提是提供了正确的RPL**；
- **内核或者操作系统负责鉴别请求者的身份，并有义务保证RPL 的值和它的请求者身份相符**，因为这是处理器无能为力的。

操作系统的编写者很清楚段选择子的来源，即，真正的请求者是谁。

- 当它自己读写一个段时，这没有什么好说的；

- 当它提供一个服务例程时，3 特权级别的用户程序给出的选择子在哪里，也是由它定的，它也
  知道。**在这种情况下，它所要做的，就是将该选择子的RPL 字段设置为请求者的特权级**（可以使用`arpl` 指令）。

- 剩下的工作就看处理器了。每当处理器执行一个将段选择子传送到段寄存器（DS、ES、FS、GS）的指令，比如：`mov ds,cx`时，会检查以下两个条件是否都能满足。

  -  **当前特权级CPL** 高于或者和**数据段描述符的DPL** 相同。即，在数值上，CPL≤数据段描述符的DPL；
  - **请求特权级RPL** 高于或者和**数据段描述符的DPL** 相同。即，在数值上，RPL≤数据段描述符的DPL。

  如果以上两个条件不能同时成立，处理器就会阻止这种操作，并引发异常中断。





**基本的特权级检查规则总结：**

- 首先，**将控制直接转移到非依从的代码段**，要求当前特权级**CPL** 和请求特权级**RPL** 都等于**目标代码段描述符的DPL**。即，在数值上

  ```assembly
  CPL=目标代码段描述符的DPL
  RPL=目标代码段描述符的DPL
  ```

- 其次，要**将控制直接转移到依从的代码段**，要求当前特权级**CPL** 和请求特权级**RPL** 都低于，或者和**目标代码段描述符的DPL** 相同。即，在数值上，

  ```assembly
  CPL>=目标代码段描述符的DPL
  RPL>=目标代码段描述符的DPL
  ```

  控制转移后，当前特权级保持不变。

- **通过门实施的控制转移**，其特权级检查规则将在相应的章节里详述。

- 第三，高特权级别的程序可以访问低特权级别的数据段，但低特权级别的程序不能访问高特权级别的数据段。**访问数据段**之前，肯定要对段寄存器DS、ES、FS 和GS 进行修改，比如`mov fs,ax`在这个时候，要求当前特权级**CPL** 和请求特权级**RPL** 都必须高于，或者和**目标数据段描述符的DPL** 相同。即，在数值上，

  ```assembly
  CPL<=目标数据段描述符的DPL
  RPL<=目标数据段描述符的DPL
  ```

- 最后，处理器要求，在任何时候，**栈段的特权级别必须和当前特权级CPL 相同**。因此，随着程序的执行，要对段寄存器SS 的内容进行修改时，必须进行特权级检查。以下就是一个修改段寄存器SS 的例子：

  ```assembly
  mov ss,ax
  ```

  在对段寄存器SS 进行修改时，要求当前特权级**CPL** 和请求特权级**RPL** 必须等于**目标栈段描述符的DPL**。即，在数值上，

  ```assembly
  CPL=目标栈段描述符的DPL
  RPL=目标栈段描述符的DPL
  ```









### 内核程序的初始化

本章没有提供主引导程序，因为我们要继续使用上一章的主引导程序。毕竟，主引导程序只是用来加载内核程序，并执行前期的内核初始化工作。主引导程序工作在0 特权级。



因为加载的是内核程序，而内核应当工作在0 特权级，所以主引导程序在初始化内核时，所创建的描述符，其目标特权级DPL 都为0，如图14-8 所示。

![1725258565707](assets/1725258565707.png)









#### 调用门

在上一章里，内核的主要功能是加载和重定位用户程序，并将处理器的控制权移交过去。用户程序执行完毕，还要重新回收控制。

在本章里，内核也做同样的工作。**不同之处在于，它将用户程序的特权级定为3，也就是最低的特权级别。**

本章将继续沿用第13 章的用户程序，**只不过要作为一个任务进行加载**，加载的方法和上一章是不同的。而且，**运行时的特权级别是3**，不再是上一章中的0。



为了方便应用程序的编写，内核通常要提供大量的例程供它们调用。例如，在第13 章中，用户程序可以调用内核例程@PrintString 和@ReadDiskData。为此，用户程序需要定义SALT 表，并在表中填写例程的符号名。之后，再由内核将符号名转换成入口地址，也就是该例程所对应的段选择子和段内偏移量。

但是，考虑一下，在本章中，用户程序运行时的特权级别将会是3。由于处理器禁止将控制从特权级低的程序转移到特权级高的程序，因此，如果还像以前那样直接调用内核例程，百分之百不会成功，一定会引发处理器异常中断。但是，现实的需求也不能不予考虑，**任何操作系统都应当提供大量的功能调用服务。为此，需要安装调用门。**

**调用门（Call-Gate）**用于在**不同特权级的程序之间进行控制转移**。本质上，它只是一个**描述符**，一个不同于代码段和数据段的描述符，可以安装在GDT 或者LDT 中。该描述符的格式如图14-9 所示，下面是低32 位，上面是高32 位。

![1725259599279](assets/1725259599279.png)

- 调用门描述符给出了例程所在代码段的选择子。有了段选择子，就能访问描述符表得到代码段的基
  地址，这样做无非是间接了一点，但却可以在通过调用门进行控制转移时，实施代码段描述符有效性、段界限和特权级的检查。
- 例程在代码段中的偏移量也是在描述符中直接指定的，只是被分成了两个16 位的部分。
- 描述符中的TYPE 字段用于标识门的类型，共4 比特，值“1100”表示调用门。
- 描述符中的P 位是有效位，通常应该是“1”。当它为“0”时，调用这样的门会导致处理器产生异常中断。

**通过调用门实施特权级之间的控制转移时**，可以使用`jmp far` 指令，也可以使用`call far `指令。如果是后者，会改变当前特权级CPL。**因为栈段的特权级必须同当前特权级保持一致，因此，还要切换栈**，即，从低特权级的栈切换到高特权级的栈。这主要是为了防止因栈空间不足而产生不可预料的问题，同时也是为了防止栈数据的交叉引用。

为了切换栈，每个任务除了自己固有的栈之外，还必须额外定义几套栈，具体数量取决于任务的特权级别。

- **0 特权级任务**不需要额外的栈，它自己固有的栈就足够使用，因为除了调用返回外，不可能将控制转移
  到低特权级的段；
- **1 特权级的任务**需要额外定义一个描述符特权级DPL为0 的栈，以便将控制转移到0 特权级时使用；
- **2 特权级的任务**则需要额外定义两个栈，描述符特权级DPL 分别是0 和1，在控制转移到0 特权级和1 特权级时使用；
- **3 特权级的任务**最多额外定义3 个栈，描述符特权级分别是0、1 和2，在控制转移到0、1 和2 特权级时使用。

不要担心，**这些额外的栈，也会由操作系统加载程序时自动创建**，本章的源代码就演示了这一过程。

**这些额外创建的栈，其描述符位于任务自己的LDT 中。同时，还要在任务的TSS 中登记**，原因是，栈切换是由处理器固件自动完成的，处理器需要根据TSS 中的信息来完成这一过程。

任务寄存器TR 总是指向当前任务的任务状态段TSS，其内容为该TSS 的基地址和界限。

通过**调用门**使用高特权级的例程服务时，**调用者会传递一些参数给例程**。如果是通过寄存器传送，这没有什么可说的。不过，要传递的参数很多时，更经常的做法是通过**栈**进行。**调用者把参数压入栈，例程从栈中取出参数**。在高级语言里，这是一贯的做法。

例程需要什么参数，先压入哪个参数，后压入哪个参数，这是调用者和例程之间的约定，调用者是清楚的。特别是，**当栈切换时**，参数还在旧栈中。为了使例程能获得参数，必须**将参数从旧栈复制到新栈中**。

**参数的复制工作是由处理器固件完成的**，但它必须事先知道参数的个数，并根据该数量决定复制多少内容。所以，调用门描述符中还有一个参数个数字段，共5 比特。

栈切换前，段寄存器SS 指向的是旧栈，ESP 指向旧栈的栈顶，即最后一个被压入的过程参数；栈切换后，处理器自动替换SS 和ESP 寄存器的内容，使它们分别为新栈的选择子和新栈的栈顶（最后一个被复制的参数）。这一切，对程序的编写者来说是透明的。

**调用门描述符中的DPL** 和**目标代码段描述符的DPL** 用于决定哪些特权级的程序可以访问此门。具体的规则是必须同时符合以下两个条件才行：

- 当前特权级CPL 和请求特权级RPL 高于，或者和调用门描述符特权级DPL 相同。即，在数值上

  ```assembly
  CPL<=调用门描述符中的DPL
  RPL<=调用门描述符中的DPL
  ```

- 当前特权级CPL 低于，或者和目标代码段描述符特权级DPL 相同。即，在数值上

  ```assembly
  CPL>=目标代码段描述符的DPL
  ```



如图14-10 所示，**调用门的DPL 是特权级检查的下限**。除此之外，目标代码段的特权级也是需要考虑的因素。**调用门描述符中有目标代码段的选择子，它指向目标代码段的描述符**。当一个程序通过调用门转移
控制时，**处理器还要检查目标代码段描述符的DPL，该DPL 决定了调用门特权级检查的上限**。也就是说，只有那些特权级低于或者等于目标代码段DPL 的程序才允许使用此门。

![1725261957490](assets/1725261957490.png)









#### 调用门的安装和测试

如图14-11，安装调用门后的GDT布局

![1725262003541](assets/1725262003541.png)









### 加载用户程序并创建任务

#### 任务控制块和TCB 链

在内核初始化完成后，和第13 章一样，接下来的工作就是**加载和重定位用户程序（ 应用程序），并移交控制权**。加载程序并创建一个任务，需要用到很多数据，比如程序的大小、加载的位置，等等。当任务执行结束，还要依据这些信息来回收它所占用的内存空间。还有，多任务系统是多个任务同时运行的，特别是在一个单处理器（核）的系统中，为了在任务之间切换和轮转，必须能追踪到所有正在运行的任务，记录它们的状态，或者根据它们的当前状态来采取适当的操作

为了满足以上的要求，内核应当为每一个任务创建一个内存区域，来记录任务的信息和状态，称为**任务控制块（Task Control Block，TCB）**。

如图14-12 所示，这是**任务控制块的结构**

![1725438980972](assets/1725438980972.png)





为了能够追踪到所有任务，应当把每个**任务控制块TCB** 串起来，形成一个**链表**

如图14-13 所示，所有任务都按照被创建的先后顺序链接在一起，从tcb_chain 开始，可以依次找到每一个任务。

![1725439029229](assets/1725439029229.png)







#### 使用栈传递过程参数

下 面 的 工 作 是 加 载 和 重 定 位 用 户 程 序 ， 依 然 是 在 过 程load_relocate_program 中进行。该过程需要传入两个参数，分别是用户程序的起始逻辑扇区号，以及它的任务控制块TCB 线性地址。和上一章不同的是，参数不是用寄存器传入的，而是采用**栈**。原因很简单，寄存器数量有限，况且还要在过程内部使用，当传入的参数很多时，**栈**是最好的选择。



栈的访问有两种：

- 一种是隐式的，由处理器在执行诸如push、pop、call、ret 等指令时自动进行。隐式地访问栈需要使用指令指针寄存器ESP。
- 另一种访问栈的方式不依赖于先进后出机制，而是**把栈看成是一般的数据段**，直接访问其中的任何内容。在这种方式下，需要使用**栈基址寄存器EBP**。
  - 很显然，用EBP 寄存器来寻址时，不需要使用段超越前缀“SS:”，因为**EBP 寄存器出现在指令中的地址部分时，默认使用段寄存器SS。**



如图14-15 所示，这是用ESP 寄存器的内容初始化EBP 后，栈的状态

![1725439673041](assets/1725439673041.png)

当前的栈顶位置是SS:EBP，指向一个双字，是段寄存器ES 的内容，因为最近一次的压栈操作是

```assembly
push es
```







#### 加载用户程序

当用户程序被读入内存，并处于运行或者等待运行的状态时，就视为一个任务。任务有自己的代码段和数据段（包括栈），这些段必须通过描述符来引用，而这些描述符可以放在GDT 中，也可以放在任务自己私有的LDT 中，但最好是放在LDT 中。GDT 用于存放各个任务公有的描述符，比如公共的数据段和公共例程。

每个任务都允许有自己的LDT，而且可以定义在任何内存位置。所以，我们现在要做三件事：

- 分配一块内存，作为LDT 来用，为创建用户程序各个段的描述符做准备；
- 将LDT 的大小和起始线性地址登记在任务控制块TCB 中；
- 分配内存并加载用户程序，并将它的大小和起始线性地址登记到TCB 中。







#### 创建局部描述符表

用户程序已被加载到内存中，现在该是在LDT 中创建段描述符的时候了。







#### 重定位U-SALT 表

接着回到代码清单14-1 中。

从第539 行开始，一直到第576 行结束，分别是创建用户程序代码段、数据段和栈段描述符，并将它们安装在LDT 中。但是，必须要说明的是，在这个过程中所创建的段描述符，其特权级DPL 都是3，而且，这些段描述符的选择子，其请求特权级 RPL 也都是3。

从第579 行开始，到第620 行结束，用于重定位用户程序的U-SALT表。





#### 创建0、1 和2 特权级的栈

任务在运行时，需要调用内核或者操作系统的例程。这可以认为是从同一个任务的局部地址空间转移到全局地址空间工作。而且，在这个过程中涉及特权级的变化，需要通过调用门。

通过调用门的控制转移通常会改变当前特权级CPL，同时还要切换到与目标代码段特权级相同的栈。为此，必须为每个任务定义额外的栈。对于当前的3 特权级任务来说，应当创建特权级0、1 和2 的栈。而且，应当将它们定义在每个任务自己的LDT 中。

这些额外的栈是动态创建的，而且需要登记在任务状态段（TSS）中，以便处理器固件能够自动访问到它们。但是，现在的问题是还没有创建TSS，有必要先将这些栈信息登记在任务控制块（TCB）中暂时保存。







#### 安装LDT 描述符到GDT 中

尽管局部描述符表（LDT）和全局描述符表（GDT）都用来存放各种描述符，比如段描述符，但这掩盖不了它们也是内存段的事实。简单地说，它们也是段。但是，因为它们用于系统管理，故称为系统的段或系统段。

全局描述符表（GDT）是唯一的，整个系统中只有一个，所以只需要用GDTR 寄存器存放其线性基地址和段界限即可；但LDT 不同，每个任务一个，所以，为了追踪它们，处理器要求在GDT 中安装每个LDT 的描述符。当要使用这些LDT 时，可以用它们的选择子来访问GDT，将LDT 描述符加载到LDTR 寄存器。





#### 任务状态段TSS 的格式

到目前为止，任务的所有内存段都已创建完毕，除了任务状态段（TSS）。现在就来创建TSS。在此之前，先来全面了解一下TSS 的各个组成部分。



如图14-18 所示，任务状态段TSS 的最小长度是104 字节，保存着最基本的任务信息，但这并不是它的最大长度。

![1725441183775](assets/1725441183775.png)









#### 创建任务状态段TSS

回到代码清单14-1，我们来创建任务状态段TSS。

第684～688 行，申请104 字节的内存用于创建TSS。很显然，我们是要创建一个标准大小的TSS。照例，要把TSS 的基地址和界限登记到任务控制块（TCB）中，将来创建TSS 描述符时用得着。TSS 的界限值是16 位的，是它的大小（总字节数）减1，这就是第686 行的目的。





#### 安装TSS 描述符到GDT 中

和局部描述符表（LDT）一样，也**必须在GDT 中安装TSS 的描述符**。这样做，一方面是为了对TSS 进行段和特权级的检查；另一方面，也是执行任务切换的需要。当call far 和jmp far 指令的操作数是TSS 描述符选择子时，处理器执行任务切换操作。



如图14-19 所示，这是TSS 描述符的格式，和LDT 描述符差不多，除了TYPE 位。

TSS 描述符中的B 位是“忙”位（Busy）。在任务刚刚创建的时候，它应该为二进制的1001，即，B 位是0，表明任务不忙。当任务开始执行时，或者处于挂起状态（临时被中断执行）时，由处理器固件把B 位置1。

![1725441470645](assets/1725441470645.png)







#### 带参数的过程返回指令

至此，任务创建完毕，可以从过程load_relocate_program 返回了。



如图14-20 所示，当执行ret 指令时，栈恢复到刚进入过程时的状态，即，只有返回地址和调用者传递给过程的参数。因为当初是采用32位相对近调用进入过程load_relocate_program 的，故仅将EIP 压栈，没有压入段寄存器CS 的内容。

![1725441713267](assets/1725441713267.png)

再来看，一旦ret 指令执行完毕，控制将返回到调用者，且栈中只剩下两个参数。

















### 用户程序的执行

#### 通过调用门转移控制的完整过程

我们创建的是一个3 特权级的任务，所以这是一个从0 特权级到3 特权级的控制转移。是从任务自己的0 特权级全局空间转移到3 特权级局部空间执行。通常情况下，这既不允许，也不太可能。

办法总还是有的，只不过稍微有一点曲折，那就是**假装从调用门返回**。





先来看看完整的调用门控制转移和返回过程是怎样的。

首先，通过调用门实施控制转移，可以使用jmp far 和call far 指令。指令执行时，描述符选择子必须指向调用门，32 位偏移量被忽略。但，无论采用哪种控制转移指令，都会使用表14-1 的特权检查规则。注意，表中的比较关系都是数值上的。

![1725606273547](assets/1725606273547.png)

使用call far 指令可以通过调用门将控制转移到较高特权级别的代码段。

当使用call far 指令通过调用门转移控制时，如果改变了当前的特权级别，则必须切换栈。即，从当前任务的固有栈切换到与目标代码段特权级相同的栈上。栈的切换是由处理器固件自动进行的。

当前栈是由段寄存器SS 和栈指针寄存器ESP 的当前内容指示的；要切换到的新栈位于当前任务的TSS 中，处理器知道如何找到它。在栈切换前，处理器要检查新栈是否有足够的空间完成本次控制转移。**栈切换过程如下：**

- ① 使用目标代码段的DPL（也就是新的CPL）到当前任务的TSS 中选择一个栈，包括栈段选择子和栈指针。

- ② 从TSS 中读取所选择的段选择子和栈指针，并用该选择子读取栈段描述符。在此期间，任何违反段界限检查的行为都将引发处理器异常中断（无效TSS）。

- ③ 检查栈段描述符的特权级和类型，并可能引发处理器异常中断（无效TSS）。

- ④ 临时保存当前栈段寄存器SS 和栈指针ESP 的内容。

- ⑤ 把新的栈段选择子和栈指针代入SS 和ESP 寄存器，切换到新栈。

- ⑥ 将刚才临时保存的SS 和ESP 的内容压入当前栈，如图14-21 所示。

  ![1725606467982](assets/1725606467982.png)

- ⑦ 依据调用门描述符“参数个数”字段的指示，从旧栈中将所有参数都复制到新栈中。如果参数个数为0，不复制参数，如图14-21 所示。

- ⑧ 将当前段寄存器CS 和指令指针寄存器EIP 的内容压入新栈，如图14-21 所示。通过调用门实施的控制转移一定是远转移，所以要压入CS和EIP。

- ⑨ 从调用门描述符中依次将目标代码段选择子和段内偏移传送到CS和EIP 寄存器，开始执行被调用过程。

相反，如果没有改变特权级别，则不切换栈，继续使用调用者的当前栈，只在原来的基础上压入当前段寄存器CS 和指令指针寄存器EIP 的内容，如图14-22 所示。

![1725606611912](assets/1725606611912.png)







如果通过调用门的控制转移是使用call far指令发起的，那么，可以使用远返回指令retf 把控制返回到调用者。

**要求特权级变化的远返回，只能返回到较低的特权级别上。控制返回的全部过程如下**：

- ① 检查栈中保存的CS 寄存器的内容，根据其RPL 字段决定返回时是否需要改变特权级别。
- ② 从当前栈中读取CS 和EIP 寄存器的内容，并针对代码段描述符和代码段选择子的RPL 字段实施特权级检查。
- ③ 如果远返回指令是带参数的，则将参数和ESP 寄存器的当前值相加，以跳过栈中的参数部分。最后的结果是ESP 寄存器指向调用者SS和ESP 的压栈值。
- ④ 如果返回时需要改变特权级，从栈中将SS 和ESP 的压栈值代入段寄存器SS 和指令指针寄存器ESP，切换到调用者的栈。
- ⑤ 如果远返回指令是带参数的，则将参数和ESP 寄存器的当前值相加，以跳过调用者栈中的参数部分。
- ⑥ 如果返回时需要改变特权级，检查DS、ES、FS 和GS 寄存器的内容，根据它们找到相应的段描述符。



**特权级检查**不是在实际访问内存时进行的，而是在**将选择子代入段寄存器时**进行的







#### 进入3 特权级的用户程序的执行









#### 检查调用者的请求特权级RPL































### 